
### 高性能网络模式：Reactor vs Proactor**
**演进背景**  
传统多线程/进程模型（每连接一线程）存在资源浪费和性能瓶颈。优化方案：  
1. **资源复用**：线程池处理多连接。  
2. **非阻塞 I/O**：线程轮询数据，但 CPU 消耗高。  
3. **I/O 多路复用**：通过 `select/poll/epoll` **单线程监听多连接事件**，事件就绪时通知线程处理，避免盲目轮询。

---

### **Reactor 模式**  
**核心思想**  
- **Dispatcher 模式**：I/O 多路复用监听事件，分发到对应进程/线程。  
- **组成**：  
  - **Reactor**：监听和分发事件（连接、读写）。  
  - **处理资源池**：执行 `read → 业务逻辑 → send`。  

#### **三种经典方案**  
| **方案**        | **特点**        | **适用场景**                     |  
|-----------------|--------------------------|-------------------------|  
| **单 Reactor 单线程/进程**| 全部操作在同一线程/进程完成，实现简单；无法利用多核，业务耗时易阻塞。| Redis 6.0 前（内存操作快|  
| **单 Reactor 多线程**    | Reactor 主线程监听，Handler 负责 I/O，子线程处理业务；需解决线程竞争问题。| 通用场景|  
| **多 Reactor 多线程/进程**| MainReactor 接收连接，SubReactor 监听读写，Handler 处理 I/O；分工明确。| 高并发场景|  

> **注**：  
> - Nginx 变体：子进程竞争 accept 连接，独立处理请求。  
> - 进程/线程选择取决于语言（Java 用线程，C 可用进程/线程）。

---

### **Proactor 模式**  
**核心思想**  
- **异步 I/O**：内核完成**数据就绪**和**数据拷贝**后通知应用，无需主动读写。  
- **流程**：  
  1. Proactor Initiator 注册事件到内核。  
  2. 内核执行 I/O 操作并通知 Proactor。  
  3. Proactor 回调 Handler 处理数据。  

**与 Reactor 对比**  
| **模式**    | **操作方式**                    | **比喻**         |  
|-------------|-------------------------------|---------------|  
| **Reactor** | 感知**就绪事件**，应用需主动读写。 | 快递到小区，需自取。 |  
| **Proactor**| 感知**完成事件**，内核完成读写。  | 快递送货上门，直接签收。|  

**平台支持**  
- Linux：异步 I/O 不完善（仅支持文件），高性能网络用 Reactor。  
- Windows：IOCP 实现完整异步 I/O，支持 Proactor。

---

### **总结**  
1. **Reactor** 基于**就绪事件**（非阻塞同步），通过事件分发实现高并发。  
   - 单 Reactor 单线程：简单，适合快速业务（如 Redis）。  
   - 多 Reactor 多线程：高并发首选（如 Netty、Nginx）。  
2. **Proactor** 基于**完成事件**（异步 I/O），性能更高但依赖系统支持（如 Windows IOCP）。  
3. 两者本质均为**事件驱动**，区别在于事件阶段（就绪 vs 完成）。
