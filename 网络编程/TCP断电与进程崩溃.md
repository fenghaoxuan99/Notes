
### **4.12 TCP 连接：一端断电（主机崩溃）与进程崩溃的区别**  
**问题背景**  
面试题核心：在未开启 TCP keepalive 且无数据交互时，TCP 连接一端发生**进程崩溃**或**主机崩溃**的区别。  

---

#### **1. TCP keepalive 机制**  
- **作用**：检测对端 TCP 连接是否存活。  
- **工作原理**：  
  - 无数据交互时，内核发送探测报文。  
  - 对端正常响应 → 重置保活计时器。  
  - 对端无响应（如主机崩溃）→ 连续多次失败后断开连接。  
- **启用条件**：需通过 socket 设置 `SO_KEEPALIVE` 选项，否则不生效。  

---

#### **2. 主机崩溃（断电）的影响**  
- **场景**：客户端主机崩溃，服务端未开启 keepalive 且无数据交互。  
- **结果**：  
  - 服务端无法感知崩溃，TCP 连接保持 `ESTABLISHED` 状态。  
  - 连接仅在服务端重启进程后终止。  
- **关键结论**：  
  > 一方连接处于 `ESTABLISHED` 状态，不代表对端连接正常。  

---

#### **3. 进程崩溃的影响**  
- **场景**：服务端进程崩溃（如 `kill -9`）。  
- **结果**：  
  - 内核回收进程资源，主动发送 **FIN 报文**，触发四次挥手。  
  - 客户端完成挥手流程，连接正常关闭。  
- **关键结论**：  
  > 进程崩溃由操作系统感知，内核自动处理连接终止。  

---

#### **4. 有数据传输时的异常场景**  
##### **4.1 客户端主机宕机后迅速重启**  
- 服务端发送数据报文 → 无响应 → 触发超时重传。  
- 客户端重启后收到重传报文：  
  - 无进程绑定目标端口 → 回复 **RST 报文**，强制断开连接。  
  - 有进程绑定端口但丢失 TCP 结构 → 回复 **RST 报文**，断开连接。  

##### **4.2 客户端主机宕机后未重启**  
- 服务端持续重传报文，直至达到重传阈值（由 `tcp_retries2` 控制）。  
- 内核判定连接异常 → 通过 Socket 通知应用程序断开连接。  

---

#### **5. 超时重传机制详解**  
- **参数**：Linux 内核的 `tcp_retries2`（默认值 15）。  
- **超时判定**：  
  - 基于 RTO（Retransmission Timeout）指数增长：  
    - 初始 RTO ≥ 200ms（`TCP_RTO_MIN`）。  
    - 后续 RTO 按倍数递增（如 200ms → 400ms → 800ms）。  
  - 总重传时长超过阈值（由 `tcp_retries2` 计算）→ 断开连接。  
- **示例**：  
  | 重传轮次 | RTO（ms） | 累计时间（ms） |  
  |----------|-----------|----------------|  
  | 1        | 200       | 200            |  
  | 2        | 400       | 600            |  
  | 3        | 800       | 1400           |  
  | ...      | ...       | ...            |  
  | 15       | 1638400   | 约 924600（阈值） |  

---

#### **6. 总结**  
| **场景**         | **服务端行为**                               | **连接状态变化**               |  
|------------------|---------------------------------------------|-------------------------------|  
| **进程崩溃**     | 内核发送 FIN 报文，完成四次挥手。             | 正常关闭。                    |  
| **主机崩溃**     | 无感知，保持 `ESTABLISHED`。                 | 长期保持（除非服务端重启）。  |  
| **主机崩溃 + 数据传输** | 超时重传直至阈值 → 断开连接。               | 由重传机制终止。              |  
| **启用 keepalive** | 探测到对端消亡 → 主动断开。                 | 保活机制介入终止。            |  

> **关键结论**：TCP 协议通过内核机制（挥手、重传、保活）覆盖各类异常场景，确保连接可靠性。