
**Linux 系统如何收发网络包？**

**核心问题：Linux 系统如何发送和接收网络数据包？**

**一、 网络模型基础**
*   **OSI七层模型：** 国际标准提出的理论模型（应用层-表示层-会话层-传输层-网络层-数据链路层-物理层），定义了通信分层概念，但实现复杂。
*   **TCP/IP四层模型 (Linux实际采用)：** 更实用简洁的分层模型，Linux按此实现网络协议栈。
    *   **应用层 (Application)：** 提供应用程序接口 (如 HTTP, DNS, FTP)。
    *   **传输层 (Transport)：** 管理端到端通信 (如 TCP, UDP)。提供可靠性、流量控制等。
    *   **网络层 (Network)：** 负责寻址、路由、分片/重组 (如 IP, ICMP)。
    *   **网络接口层 (Link)：** 负责数据帧的封装/解封、MAC寻址、差错检测、物理传输 (如以太网)。
    *   *注：七层（应用层）和四层（传输层）负载均衡的术语源于OSI模型。*

**二、 Linux 网络协议栈**
TCP/IP 协议栈在 Linux 中的实现结构如图所示：

```
[App] -> [Socket 接口] -> ⬇️
                  传输层 (TCP/UDP)
                  网络层 (IP)
                  网络接口层 (帧处理) ⬇️
              [网卡驱动] -> [物理网卡]
```

*   应用数据在协议栈中**层层封装**：
    *   **传输层：** 添加 TCP/UDP 头部 → **段 (Segment)**
    *   **网络层：** 添加 IP 头部 → **包 (Packet)**
    *   **网络接口层：** 添加帧头/帧尾 → **帧 (Frame)**
*   **MTU (最大传输单元)：** 限制数据链路层单次传输帧的大小 (通常 1500 字节)。IP 包若大于 MTU，网络层会进行**分片**。MTU 大小影响网络效率 (小 MTU 需更多分包，吞吐可能下降)。

**三、 Linux 接收网络包流程 (关键步骤)**

1.  **网卡收包：**
    *   网卡接收数据帧。
    *   通过 **DMA** 技术将帧存入内存 **Ring Buffer** (环形队列)。
2.  **通知 CPU (硬中断 -> 软中断)：**
    *   网卡向 CPU 发出**硬件中断**。
    *   硬件中断处理程序短暂屏蔽中断，通知系统有数据到达。
    *   硬件中断处理程序发起一个**软中断 (SoftIRQ)**。
3.  **软中断处理 (`ksoftirqd`)：**
    *   内核线程 `ksoftirqd` 处理软中断，**轮询** Ring Buffer。
    *   从 Ring Buffer 中取出一个帧，封装为 `sk_buff` 结构体 (表示网络包)。
4.  **协议栈逐层处理 (自下而上)：**
    *   **网络接口层：** 检查帧合法性、拆帧头帧尾、识别上层协议 (如 IP)，`sk_buff` 交付给网络层。
    *   **网络层：** 检查 IP 包、路由决策 (目的是否为本机？)。本机则拆 IP 头，识别上层协议 (如 TCP/UDP)，提交给传输层。
    *   **传输层：** 拆 TCP/UDP 头，查找 `(源IP,源端口,目的IP,目的端口)` 对应的 **Socket**，将数据复制到该 **Socket 的接收缓冲区**。
5.  **应用程序读取：**
    *   应用程序通过 **Socket 接口**读取其接收缓冲区的数据 (从内核态复制到用户态)。

**四、 Linux 发送网络包流程 (关键步骤)**

1.  **应用层发送：**
    *   应用程序调用 Socket 接口 (系统调用) 发送数据。
    *   **系统调用**进入内核，内核创建 `sk_buff`，将用户数据**拷贝**其中并放入 **Socket 发送缓冲区**。
2.  **协议栈逐层封装 (自上而下)：**
    *   **传输层：**
        *   从发送缓冲区取 `sk_buff`。
        *   **TCP 特有：** 拷贝一份 `sk_buff` 副本用于发送 (原始 `sk_buff` 保留以备重传，收到 ACK 后释放)。
        *   添加 TCP/UDP 头。
    *   **网络层：**
        *   添加 IP 头。
        *   **路由决策** (查找下一跳 IP)。
        *   **netfilter 过滤** (防火墙等)。
        *   若 IP 包 > **MTU**，进行**分片** (创建多个小 `sk_buff`)。
    *   **网络接口层：**
        *   **ARP**: 获取下一跳 IP 对应的 **MAC 地址**。
        *   添加**帧头**(含目标 MAC 地址) 和 **帧尾**。
        *   将封装好的帧 (`sk_buff`) 放入**网卡发送队列**。
3.  **网卡发包：**
    *   触发**软中断**通知网卡驱动有新数据待发送。
    *   驱动从发送队列读取 `sk_buff`。
    *   将 `sk_buff` 挂到 **Ring Buffer**。
    *   通过 **DMA** 将数据映射到网卡内存。
    *   **网卡发送物理帧**。
4.  **清理：**
    *   发送完成后，网卡触发**硬中断**通知 CPU。
    *   驱动程序释放该`sk_buff`在Ring Buffer中的占用空间。
    *   **TCP 特有：** 收到此包 ACK 后，释放原始保留的 `sk_buff`。

**(发送流程中的内存拷贝)**
1.  **用户到内核**：应用程序数据 --> `sk_buff` (Socket 发送缓冲区)。
2.  **TCP 克隆**：传输层发送时需克隆 `sk_buff` 用于网络层处理 (原始用于重传)。
3.  **分片拷贝**：网络层分片时拷贝原始 `sk_buff` 数据。

**总结**
Linux 采用实用的 **TCP/IP 四层模型**实现网络通信。发送数据时，应用数据通过 **Socket 接口进入内核**，由协议栈**自上而下逐层封装** (传输层->网络层->网络接口层)，最终由**网卡驱动**发出；接收数据时，网卡通过 **DMA** 写入内存，触发**中断/轮询 (NAPI) 机制**通知协议栈**自下而上逐层解析** (网络接口层->网络层->传输层)，解封装后的数据通过 **Socket 接口送达应用程序**。理解这个过程需掌握协议栈分层、封装解封装、缓冲区管理和中断轮询机制等核心概念。