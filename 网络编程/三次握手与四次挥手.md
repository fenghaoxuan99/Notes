

# TCP 三次握手与四次挥手
#### TCP 基本认识  
**TCP 头格式有哪些？**  
- **序列号**：建立连接时随机生成初始值，通过 SYN 包传输，解决网络包乱序问题。  
- **确认应答号**：期望收到的下一个数据序列号，解决丢包问题。  
- **控制位**：  
  - `ACK=1`：确认应答有效（除初始 SYN 包外必须置 1）。  
  - `RST=1`：强制断开异常连接。  
  - `SYN=1`：请求建立连接，携带序列号初始值。  
  - `FIN=1`：终止连接，不再发送数据。  

**为什么需要 TCP 协议？工作在哪一层？**  
- IP 层不可靠（不保证交付、顺序、完整性），TCP 在传输层提供可靠数据传输。  
- OSI 模型：TCP 位于传输层，确保数据无损坏、无间隔、按序到达。  

**什么是 TCP？**  
- 面向连接、可靠、基于字节流的传输层协议：  
  - 一对一连接（不支持广播）。  
  - 保证报文可达接收端。  
  - 消息被分组为有序 TCP 报文，自动丢弃重复报文。  

**什么是 TCP 连接？**  
- 定义（RFC 793）：由 Socket、序列号、窗口大小组合的状态信息，用于保证可靠性和流量控制。  
- 建立连接需客户端与服务端就三者达成共识。  

**如何唯一确定 TCP 连接？**  
- **TCP 四元组**：源地址、源端口、目的地址、目的端口。  
- 最大连接数理论值：IPv4 客户端的 IP 数（2^32） × 端口数（2^16）≈ 2^48。  
- 实际限制：文件描述符数量、内存资源、进程级限制。  

**UDP 和 TCP 的区别及应用场景？**  
| **对比项**       | **TCP**                            | **UDP**                          |  
|------------------|------------------------------------|----------------------------------|  
| 连接             | 面向连接（需握手）                 | 无连接                           |  
| 服务对象         | 一对一                             | 支持一对一、一对多、多对多       |  
| 可靠性           | 可靠交付（不丢、不重、按序）       | 尽最大努力交付                   |  
| 拥塞/流量控制    | 有                                 | 无                               |  
| 首部开销         | 20-60 字节（可变长）               | 固定 8 字节                     |  
| 传输方式         | 流式传输（无边界）                 | 数据包（有边界）                 |  
| 分片             | 传输层分片（丢失仅重传分片）       | IP 层分片（丢失需重传整个包）    |  
| **应用场景**     | FTP/HTTP/HTTPS                     | DNS/SNMP/音视频/广播             |  

**TCP 和 UDP 可使用同一端口吗？**  
- **可以**。TCP/UDP 是独立模块，通过 IP 包头的协议号区分，端口号在各自命名空间中独立。  

---

#### TCP 连接建立  
**三次握手过程**  
1. **SYN**（客户端 → 服务端）：  
   - 客户端发送 `SYN=1` + 随机初始序列号 `client_isn`，进入 `SYN-SENT` 状态。  
2. **SYN+ACK**（服务端 → 客户端）：  
   - 服务端发送 `SYN=1` + `ACK=1` + 随机初始序列号 `server_isn` + 确认号 `client_isn+1`，进入 `SYN-RCVD` 状态。  
3. **ACK**（客户端 → 服务端）：  
   - 客户端发送 `ACK=1` + 确认号 `server_isn+1`（可携带数据），进入 `ESTABLISHED` 状态。  
   - 服务端收到后进入 `ESTABLISHED` 状态。  

**为何是三次握手？**  
1. **阻止历史连接**（主因）：  
   - 旧 SYN 报文可能因网络延迟滞留，三次握手通过序列号验证报文时效性。  
2. **同步初始序列号**：  
   - 双方需确认对方的初始序列号，确保数据按序传输。  
3. **避免资源浪费**：  
   - 两次握手可能因 SYN 滞留导致服务端建立冗余连接。  

**初始序列号（ISN）随机化原因**  
- 防止历史报文被相同四元组的新连接错误接收。  
- 增强安全性，避免伪造序列号攻击。  

**第一次握手丢失**  
- 客户端超时重传 SYN（次数由 `tcp_syn_retries` 控制，默认 5 次），总耗时约 63 秒。  

**第二次握手丢失**  
- 客户端重传 SYN（受 `tcp_syn_retries` 限制）。  
- 服务端重传 SYN+ACK（受 `tcp_synack_retries` 限制，默认 5 次）。  

**第三次握手丢失**  
- 服务端重传 SYN+ACK（受 `tcp_synack_retries` 限制）。  

**SYN 攻击及防御**  
- **攻击原理**：伪造大量 IP 发送 SYN 报文占满服务端半连接队列。  
- **防御方法**：  
  1. 增大 `netdev_max_backlog`（默认 1000）。  
  2. 增大半连接队列（调整 `net.ipv4.tcp_max_syn_backlog`、`backlog`、`net.core.somaxconn`）。  
  3. 开启 `tcp_syncookies`（绕过半连接队列验证）。  
  4. 减少 `tcp_synack_retries`（降低重传次数）。  

---

#### TCP 连接断开  
**四次挥手过程**  
1. **FIN**（主动方 → 被动方）：  
   - 主动方发送 `FIN=1`，进入 `FIN-WAIT-1` 状态。  
2. **ACK**（被动方 → 主动方）：  
   - 被动方发送 `ACK=1`，进入 `CLOSE-WAIT` 状态。  
3. **FIN**（被动方 → 主动方）：  
   - 被动方处理完数据后发送 `FIN=1`，进入 `LAST-ACK` 状态。  
4. **ACK**（主动方 → 被动方）：  
   - 主动方发送 `ACK=1`，进入 `TIME-WAIT` 状态（等待 2MSL）。  
   - 被动方收到后进入 `CLOSED` 状态。  

**为何需四次挥手？**  
- 被动方收到 FIN 后需先确认（ACK），再处理剩余数据后发送 FIN，无法合并为三次。  

**TIME-WAIT 状态**  
- **时长**：2MSL（Linux 默认 60 秒）。  
- **作用**：  
  1. 防止历史连接数据被新连接错误接收。  
  2. 保证被动方正确关闭（若 FIN 丢失可重传）。  
- **优化方法**：  
  - 开启 `tcp_tw_reuse` + `tcp_timestamps`（客户端复用连接）。  
  - 调整 `net.ipv4.tcp_max_tw_buckets`（限制数量）。  
  - 程序设置 `SO_LINGER`（强制 RST 关闭，不推荐）。  

**挥手阶段报文丢失**  
| **丢失报文** | 主动方行为                   | 被动方行为                   |  
|--------------|------------------------------|------------------------------|  
| 第一次 FIN   | 重传 FIN（`tcp_orphan_retries`） | -                          |  
| 第二次 ACK   | 重传 FIN                     | -                          |  
| 第三次 FIN   | -                            | 重传 FIN（`tcp_orphan_retries`） |  
| 第四次 ACK   | 等待 2MSL                    | 重传 FIN（`tcp_orphan_retries`） |  

---

#### 异常场景分析  
**服务端大量 TIME-WAIT**  
- **原因**：服务端主动断开连接（如 HTTP 未用长连接、长连接超时、请求数超限）。  
- **解决**：  
  - 开启 HTTP Keep-Alive。  
  - 调整 Nginx 的 `keepalive_timeout` 和 `keepalive_requests`。  

**服务端大量 CLOSE-WAIT**  
- **原因**：被动方未调用 `close()`（代码未处理关闭逻辑或阻塞）。  
- **排查方向**：检查服务端是否漏处理连接关闭。  

**客户端故障（宕机）**  
- **TCP 保活机制**（默认参数）：  
  - `tcp_keepalive_time=7200s`（2 小时无活动后探测）。  
  - `tcp_keepalive_intvl=75s`（探测间隔）。  
  - `tcp_keepalive_probes=9`（最多探测 9 次）。  

**服务端进程崩溃**  
- 内核自动完成四次挥手，释放连接资源。  

---

#### Socket 编程  
**TCP 通信流程**  
1. 服务端：`bind()` → `listen()` → `accept()` → `read()`/`write()` → `close()`。  
2. 客户端：`connect()` → `write()`/`read()` → `close()`。  

**关键函数**  
- `listen(backlog)`：  
  - `backlog` 为全连接队列长度（Linux 2.2+），上限值 `min(backlog, somaxconn)`。  
- `accept()`：  
  - 发生在三次握手完成后，从全连接队列取出 socket。  
- 无 `accept()`/`listen()` 仍可建立连接（如 TCP 自连接）。  

**客户端调用 `close()` 流程**  
1. 客户端发 FIN → 进入 `FIN-WAIT-1`。  
2. 服务端回 ACK → 进入 `CLOSE-WAIT`。  
3. 服务端发 FIN → 进入 `LAST-ACK`。  
4. 客户端回 ACK → 进入 `TIME-WAIT`（2MSL 后关闭）。  

