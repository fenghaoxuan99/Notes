
# **TCP 四次挥手能否变成三次？**

**核心问题：** TCP 四次挥手过程中，能否将第二次的 ACK 报文与第三次的 FIN 报文合并发送？

**结论：** **是**。在特定条件下，TCP 四次挥手可以变为三次挥手。这在实际抓包（如 Wireshark）中很常见。

**一、标准 TCP 四次挥手流程**
![alt text](../Image/四次挥手断开.png)
1.  **FIN (Client -> Server):** 主动关闭方（客户端）发送 FIN 报文，进入 `FIN_WAIT_1` 状态，表示不再发送数据。
2.  **ACK (Server -> Client):** 被动关闭方（服务器）收到 FIN 后，**立即**回复 ACK 报文，进入 `CLOSE_WAIT` 状态。
    *   *内核行为：* TCP 协议栈会在接收缓冲区为 FIN 包插入 EOF。应用需通过 `read` 感知此 EOF。
3.  **FIN (Server -> Client):** 服务器应用程序读取到 EOF (`read` 返回 0) 后：
    *   若有数据待发，先发完数据再调用关闭函数。
    *   若无数据待发，直接调用关闭函数。
    *   调用关闭函数后，内核发送 FIN 报文，服务器进入 `LAST_ACK` 状态。
4.  **ACK (Client -> Server):** 客户端收到 FIN 后，发送 ACK 报文，进入 `TIME_WAIT` 状态。服务器收到此 ACK 后进入 `CLOSED` 状态。客户端等待 2MSL 后也进入 `CLOSED` 状态。

**关键点：** 第二次挥手（ACK）由内核立即触发，第三次挥手（FIN）由应用程序控制（调用 `close` 或 `shutdown` 后触发）。因此，ACK 和 FIN **通常**分开发送，形成四次挥手。

**二、为什么需要四次挥手？**
*   根本原因在于**第二次挥手（ACK）和第三次挥手（FIN）的触发时机和控制权不同**。
*   ACK 是内核对接收 FIN 的**即时确认**。
*   FIN 需要等待应用程序处理完接收缓冲区的数据（读到 EOF）并**主动调用关闭连接的函数**后，才由内核发出。
*   应用程序处理数据和决定关闭的时机不确定，导致 ACK 和 FIN 无法保证同时发送。

**三、关闭连接的函数：`close` vs `shutdown`**
*   **`close` (粗暴关闭):**
    *   同时关闭 Socket 的发送和读取方向。
    *   对于共享 Socket，仅减少引用计数。引用计数为 0 时才发 FIN。
    *   若在挥手过程中收到对方数据，会回 RST 报文强制中断连接（非优雅关闭）。
*   **`shutdown` (优雅关闭):**
    *   可指定关闭方向（发送、接收或两者）。
    *   立即影响共享 Socket 的所有进程，并触发 FIN 发送（若关闭了发送方向）。
    *   若指定只关闭发送方向，仍可接收数据，能完成标准四次挥手（优雅关闭）。
    *   *重要：* 仅关闭读取方向不会触发 FIN 发送（因仍能发送数据）。

**四、何时会出现三次挥手？**
*   **条件：** 当被动关闭方（服务器）同时满足以下两点时：
    1.  **没有数据要发送给主动关闭方（客户端）。**
    2.  **开启了 TCP 延迟确认机制（默认开启）。**
*   **过程：**
    1.  客户端发送 FIN (第一次挥手)。
    2.  服务器收到 FIN，按延迟确认机制，本应延迟发送 ACK。
    3.  但服务器应用程序**无数据要发送**，会**立即调用关闭函数**，触发内核发送 FIN。
    4.  此时，内核发现有一个待发送的 ACK 和一个待发送的 FIN，且**没有应用层数据**，会将 **ACK 和 FIN 合并**在一个报文中发送给客户端（第二次+第三次挥手合并）。
    5.  客户端回复 ACK (第四次挥手)。
*   **结果：** 挥手过程变为：FIN (Client) -> **ACK+FIN (Server)** -> ACK (Client)。

**五、TCP 延迟确认机制**
*   **目的：** 提高网络效率，减少纯 ACK 报文（40字节头，无数据）的数量。
*   **策略：**
    *   有响应数据要发送时，ACK 随数据**立即发送**。
    *   无响应数据时，ACK **延迟等待** (Linux 默认 40ms - 200ms)，看是否有数据可一起发送。
    *   延迟等待期间若收到对方第二个数据包，则**立即发送 ACK**。
*   **关闭方法：** 在 Socket 上设置 `TCP_QUICKACK` 选项为 1。
    ```c
    int value = 1;
    setsockopt(socketfd, IPPROTO_TCP, TCP_QUICKACK, (char*)&value, sizeof(int));
    ```
    *   *注意：* `TCP_QUICKACK` 非永久生效，通常需在每次读取数据后重新设置。

**六、实验验证结论**
1.  **实验一 (默认延迟确认开启 + 服务器无数据发送):**
    *   抓包结果显示为 **三次挥手** (FIN -> ACK+FIN -> ACK)。
    *   验证了条件满足时合并发生。
2.  **实验二 (关闭延迟确认 + 服务器无数据发送):**
    *   服务器在 `read` 返回 0 (感知到 FIN/EOF) 后，立即设置 `TCP_QUICKACK=1` 关闭延迟确认。
    *   抓包结果显示为标准的 **四次挥手** (FIN -> ACK -> FIN -> ACK)。
    *   验证了关闭延迟确认会阻止合并。

**总结**
TCP 四次挥手变为三次挥手的现象，本质是由于 **TCP 延迟确认机制** 和 **被动关闭方恰好没有待发送数据** 共同作用的结果。当这两个条件满足时，内核会将第二次挥手（ACK）和第三次挥手（FIN）合并传输，从而减少一次报文交互。这是 TCP 协议栈的一种常见优化。
