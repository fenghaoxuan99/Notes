
### **TCP序列号与确认号变化机制**
#### **核心公式**
1. **发送报文序列号计算**  
   `当前序列号 = 上一次发送序列号 + 数据长度（len）`  
   **特殊场景**：  
   - 若上一次发送的是 `SYN` 或 `FIN` 报文，则 `序列号 = 上一次序列号 + 1`

2. **确认号计算**  
   `确认号 = 上一次接收报文的序列号 + 数据长度（len）`  
   **特殊场景**：  
   - 若收到的是 `SYN` 或 `FIN` 报文，则 `确认号 = 上一次接收序列号 + 1`

> **关键概念**  
> - **序列号**：解决网络包乱序问题，初始值为随机数（`ISN`），每次发送数据累加 `len`。  
> - **确认号**：解决丢包问题，表示期望接收的下一个数据起始序列号。  
> - **控制位**：标识报文类型（如 `SYN`/`ACK`/`FIN`）。

---

#### **三次握手阶段变化**
| 步骤         | 发送方  | 序列号       | 确认号     | 计算逻辑说明       |
|--------------|---------|--------------|-------|-------|
| 第一次握手  | 客户端  | `client_isn`| -   | 初始序列号         |
| 第二次握手  | 服务端  | `server_isn` | `client_isn + 1` | 收到 `SYN` 报文（特殊场景），确认号 = 接收序列号 `client_isn` + 1     |
| 第三次握手   | 客户端  | `client_isn + 1`      | `server_isn + 1`     | 发送 `ACK`（无数据，`len=0`），序列号延续；确认号 = 服务端 `SYN` 序列号 + 1 |

> **为什么 SYN 报文确认号要 +1？**  
> - 告知对方已收到 `SYN`；  
> - 声明期望接收的下一个报文起始序列号（如服务端期望 `client_isn + 1`）。

---

#### **数据传输阶段变化**
**场景**：客户端发送 10 字节数据（`len=10`）  
| 步骤     | 发送方   | 序列号  | 确认号    | 计算逻辑说明            |
|---------|---------|--------|-------------|---------------------|
| 客户端发送数据     | 客户端  | `client_isn + 1`      | `server_isn + 1`     | 序列号延续握手结束值；确认号不变（未收到新数据）                           |
| 服务端回复 ACK     | 服务端  | `server_isn + 1`      | `client_isn + 11`    | 序列号延续；确认号 = 客户端数据序列号 `(client_isn+1)` + 数据长度 `10`     |

> **特殊场景**：若第三次握手 `ACK` 丢失，但客户端发送了数据报文（含 `ACK` 标志），服务端仍能正常建立连接并接收数据。

---

#### **四次挥手阶段变化**
| 步骤         | 发送方  | 序列号      | 确认号    | 计算逻辑说明     |
|--------|-----|--------------|-----------|-----------------------|
| 第一次挥手   | 客户端  | `client_isn + 11`     | `server_isn + 1`     | 序列号 = 上一次发送序列号 `(client_isn+1)` + 数据长度 `10`；确认号延续     |
| 第二次挥手   | 服务端  | `server_isn + 1`      | `client_isn + 12`    | 序列号延续；确认号 = 收到 `FIN` 序列号 `(client_isn+11)` + 1（特殊场景）   |
| 第三次挥手   | 服务端  | `server_isn + 1`      | `client_isn + 12`    | 同第二次挥手                                                               |
| 第四次挥手   | 客户端  | `client_isn + 12`     | `server_isn + 2`     | 序列号 = 上一次 `FIN` 序列号 `(client_isn+11)` + 1；确认号 = 服务端 `FIN` 序列号 `(server_isn+1)` + 1 |

---

### **关键总结**
1. **SYN/FIN 报文**：虽不携带数据，但被视为 `len=1` 的报文，触发序列号/确认号 +1。  
2. **连续性**：序列号与确认号严格遵循公式，确保数据有序性和可靠性。  
3. **抓包分析**：结合万能公式可清晰解读实际抓包中的序列号变化逻辑。
