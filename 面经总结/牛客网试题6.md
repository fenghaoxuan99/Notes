
1. 关于C++中的友元函数说法正确的是（      ）  
   A. 友元函数需要通过对象或指针调用  
   B. 友元函数是不能被继承的  
   C. 友元函数没有this指针  
   D. 友元函数破坏了继承性机制  
   **正确答案：BC**  
   **你的答案：AB**  
   **官方解析：**  
   友元函数是C++中一种特殊的函数机制：  
   - B正确：友元函数不能被继承，友元关系不具有传递性。  
   - C正确：友元函数不是类的成员函数，因此没有this指针。  
   - A错误：友元函数是独立函数，可直接调用，无需通过对象或指针。  
   - D错误：友元函数破坏封装性，但不影响继承机制。  
   知识点：C++、算法工程师、大数据开发工程师、2019、数据挖掘工程师

---

2. 设有语句 `char a = '\72';`，则关于变量a的说法正确的是（）  
   A. 包含2个字符  
   B. 说明不合法  
   C. 包含1个字符  
   D. 包含3个字符  
   **正确答案：C**  
   **官方解析：**  
   `\72` 是八进制转义字符（十进制值58，对应ASCII字符`:`），代表单个字符。  
   - A错误：转义序列被解析为单一字符。  
   - B错误：八进制表示法在C/C++中合法。  
   - D错误：源代码中的3个字符（`\`、`7`、`2`）仅表示一个转义字符。

---

3. 关于C++中友元的说法，正确的是（）  
   A. 一个类的友元类中的成员函数都是这个类的友元函数  
   B. 如果函数fun被声明为类A的友元函数，则该函数能访问A的保护成员，但不能访问私有成员  
   C. 如果函数fun被声明为类A的友元函数，则fun的形参类型不能是A  
   D. 类与类之间的友元关系可以继承  
   **正确答案：A**  
   **官方解析：**  
   - A正确：友元类的所有成员函数自动成为该类的友元函数。  
   - B错误：友元函数可访问类的所有成员（包括私有成员）。  
   - C错误：友元函数的形参可以是声明它的类类型。  
   - D错误：友元关系不可继承。  
   知识点：C++

---

4. 下面说明不正确的是（）  
   A. `char a[10]="china";`  
   B. `char a[10],*p=a; p="china";`  
   C. `char *a; a="china";`  
   D. `char a[10],*p; p=a="china";`  
   **正确答案：D**  
   **你的答案：C**  
   **官方解析：**  
   - D错误：数组名 `a` 是常量指针，不能作为赋值左值（`a="china"` 非法）。  
   - A正确：字符数组初始化合法。  
   - B正确：指针 `p` 可被重新赋值。  
   - C正确：字符指针可指向字符串常量。  
   知识点：C++、C语言

---

5. 以下定义错误的是：  
   A. `struct A{A _a;};`  
   B. `struct A{A* _a;};`  
   C. `struct A{A& _a;};`  
   D. `struct B; struct A{B& _b;}; struct B{A& _a;};`  
   **正确答案：A**  
   **你的答案：C**  
   **官方解析：**  
   - A错误：成员 `_a` 是完整对象，导致无限递归（对象大小无法确定）。  
   - B/C正确：指针/引用大小固定，不会递归。  
   - D正确：前置声明可实现相互引用。  
   知识点：C++、C语言

---

6. 有如下程序段：  
   ```cpp
   #include "stdio.h"
   class A {
   public:
       int _a;
       A() { _a = 1; }
       void print() { printf("%d", _a); }
   };
   class B : public A {
   public:
       int _a;
       B() { _a = 2; }
   };
   int main() {
       B b;
       b.print();
       printf("%d", b._a);
   }
   ```
   请问程序输出：  
   A. 22  
   B. 11  
   C. 21  
   D. 12  
   **正确答案：D**  
   **官方解析：**  
   - `b.print()` 调用基类 `A::print()`，输出基类成员 `A::_a`（值为1）。  
   - `b._a` 直接访问派生类成员 `B::_a`（值为2）。  
   输出结果为 `12`。

---

7. 对静态成员的正确描述是（）？  
   A. 静态数据成员要在类外定义和初始化  
   B. 非静态成员函数也可以操作静态数据成员  
   C. 全局变量、静态全局变量和静态局部变量都存放在内存的静态存储区域，局部变量存放在内存的栈区  
   D. 调用静态成员函数时要通过类或对象激活，所以静态成员函数拥有this指针  
   **正确答案：ABC**  
   **你的答案：BC**  
   **官方解析：**  
   - A正确：静态数据成员需在类外定义和初始化（C++17前）。  
   - B正确：非静态成员函数可访问静态成员。  
   - C正确：静态存储区存放全局/静态变量，栈区存放局部变量。  
   - D错误：静态成员函数无this指针。  
   知识点：C++、C++工程师、2018

---

8. 一个C++项目中有3个.h文件，5个.cpp文件，编译后生成的.obj文件数量是：  
   A. 3  
   B. 5  
   C. 8  
   D. 视编译器而定  
   **正确答案：B**  
   **官方解析：**  
   每个.cpp文件编译生成一个.obj文件，与.h文件数量无关。

---

9. 有代码如下：  
   ```cpp
   class Base {
   public:
       virtual ~Base() { std::cout << "Base Destructor" << std::endl; }
   };
   class Derived : public Base {
   public:
       ~Derived() { std::cout << "Derived Destructor" << std::endl; }
   };
   Base* p = new Derived();
   delete p;
   ```
   执行 `delete p` 时，控制台输出：  
   A. Base Destructor  
   B. Derived Destructor  
   C. Base Destructor Derived Destructor  
   D. Derived Destructor Base Destructor  
   **正确答案：D**  
   **官方解析：**  
   虚析构函数确保动态绑定：  
   - 先调用派生类析构函数（输出 `Derived Destructor`）。  
   - 再调用基类析构函数（输出 `Base Destructor`）。

---

10. 下面C++代码的运行结果为（）  
    ```cpp
    #include <iostream>
    template <typename T>
    class MyClass {
    public:
        static int count;
        MyClass() { ++count; }
        ~MyClass() { --count; }
    };
    template <typename T>
    int MyClass<T>::count = 0;
    int main() {
        MyClass<int> obj1;
        MyClass<double> obj2;
        std::cout << MyClass<int>::count << " " << MyClass<double>::count;
        return 0;
    }
    ```  
    A. 1 0  
    B. 1 1  
    C. 2 2  
    D. 2 1  
    **正确答案：B**  
    **你的答案：C**  
    **官方解析：**  
    `MyClass<int>` 和 `MyClass<double>` 是独立类，各自拥有静态成员 `count`：  
    - `obj1` 使 `MyClass<int>::count = 1`。  
    - `obj2` 使 `MyClass<double>::count = 1`。




### 1. Linux系统中网络管理员对WWW服务器进行访问、控制存取和运行等控制，这些控制可在下面什么文件中体现？
- **A**: httpd.conf  
- **B**: lilo.conf  
- **C**: inetd.conf  
- **D**: resolv.conf  

**正确答案**：A  
**官方解析**：  
在Linux中：  
- `httpd.conf`：网络服务器软件的配置文件，用于控制WWW服务器的访问、存取和运行  
- `lilo.conf`：引导管理程序lilo的配置文件  
- `inetd.conf`：控制系统提供的Internet服务（如开启/关闭服务）  
- `resolv.conf`：域名解析器配置文件  
**知识点**：Linux  

---

### 2. 命令 `01 07 * * 5 /usr/bash /usr/local/run.sh` 的执行时间是（）
- **A**: 每周一 5:07 分  
- **B**: 每周一 07:05 分  
- **C**: 每周五 07:01 分  
- **D**: 每周五 01:07 分  

**正确答案**：C  
**你的答案**：B  
**官方解析**：  
crontab时间字段解析（5部分）：  
- `01` → 分钟（01分）  
- `07` → 小时（07时）  
- `*` → 每月任意日  
- `*` → 每月任意月  
- `5` → 每周五  
命令含义：每周五的07:01执行脚本。  
**知识点**：Linux  

---

### 3. 下面哪些命令可以查看 sensorsfile 文件的第200-300行的内容
- **A**: `cat sensorsfile | tail -n +200 | head -n 100`  
- **B**: `cat sensorsfile| head -n 300 | tail -n +200`  
- **C**: `sed -n '200,300p' sensorsfile`  
- **D**: 其他都不正确  

**正确答案**：BC  
**官方解析**：  
- **B正确**：  
  `head -n 300` → 取前300行  
  `tail -n +200` → 从第200行开始输出 → 输出200-300行（共101行）  
- **C正确**：  
  `sed -n '200,300p'` → 直接打印200-300行  
- **A错误**：  
  `tail -n +200` → 从200行到末尾  
  `head -n 100` → 只取前100行 → 输出200-299行（缺少第300行）  
**知识点**：Linux  

---

### 4. 在下列命令中说法正确的是（多选题）
- **A**: chmod +X是给文件赋予执行权限  
- **B**: chmod 555赋予的是读写权限  
- **C**: 22端口是ssh常用端口  
- **D**: df常用于检查系统的内存  

**正确答案**：AC  
**你的答案**：A  
**官方解析**：  
- **A正确**：`chmod +x` 为文件添加可执行权限  
- **C正确**：22端口是SSH服务的默认端口  
- **B错误**：`chmod 555` 赋予权限为 `r-xr-xr-x`（读+执行，无写权限）  
- **D错误**：`df` 查看磁盘空间，内存检查用 `free`/`top`  
**知识点**：Linux  

---

### 5. 关于Linux系统的负载（Load）,以下表述正确的是______（多选题）
- **A**: 通过就绪和运行的进程数来反映  
- **B**: 可以通过top命令查看  
- **C**: 可以通过uptime查看  
- **D**: Load：2.5，1.3，1.1表示系统的负载压力在逐渐减少  

**正确答案**：BC  
**你的答案**：ACD  
**官方解析**：  
- **B/C正确**：`top` 和 `uptime` 均可查看系统负载  
- **A错误**：负载统计的是 **正在运行或不可中断状态** 的进程（非就绪状态）  
- **D错误**：  
  - `2.5`（1分钟负载） > `1.3`（5分钟负载） > `1.1`（15分钟负载）  
  - 表示 **近期负载上升**（压力增加），而非减少  
**知识点**：Linux  
