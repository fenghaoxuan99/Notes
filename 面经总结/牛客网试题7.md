
### 1. 下面的程序输出可能是什么?

```cpp
class Printer{
    public:
        Printer(std::string name) {std::cout << name;}
};
class Container{
    public:
        Container() : b("b"), a("a") {}
    Printer a;
    Printer b;
};
int main(){
    Container c;
    return 0;
}
```

- A: 可能是 "ab" 或 "ba"。 依赖于具体的实现
- B: 一直都是 "ba"
- C: 一直都是 "ab"

**正确答案**：C  
**你的答案**：B  
**官方解析**：  
这道题考察C++类成员初始化顺序的知识点。答案是"ab"是因为C++中类成员的初始化顺序取决于成员声明的顺序，而不是初始化列表中的顺序。

详细分析如下：
1. 在Container类中，成员变量的声明顺序是：
   - Printer a
   - Printer b
   不管初始化列表中的顺序如何，成员变量都会按照声明顺序进行初始化。
2. 虽然在构造函数的初始化列表中写的是`: b("b"), a("a")`，但这个顺序并不会影响实际的初始化顺序。
3. 所以实际的执行顺序是：
   - 先初始化a，打印出"a"
   - 再初始化b，打印出"b"
   最终输出就是"ab"

分析其他选项：
- A错误：输出不可能是"ba"，因为成员初始化顺序是确定的，不依赖于具体实现
- B错误：输出不可能是"ba"，原因同上

补充说明：这是C++的语言规范所规定的行为，不同的编译器对此的处理是一致的。如果想改变初始化顺序，唯一的方法是改变成员变量的声明顺序。这个规则的存在是为了保证程序行为的可预测性和一致性。

**知识点**：C++

---

### 2. 哪些因素可能会影响到一个类的大小（多选）

- A: 成员个数
- B: 函数个数
- C: 是否有虚函数
- D: 虚函数个数
- E: 静态变量个数
- F: 对齐方式

**正确答案**：ACF  
**官方解析**：  
影响类大小的关键因素包括成员个数、是否有虚函数以及对齐方式。让我们详细分析各个选项：

---

### 3. 有以下程序

```c
#include "stdio.h"
int main() {
    int c = 0,k;
    for(k = 1;k < 3;k++) {
        switch (k) {
            default : c += k;
            case   2: c++;
                break;
            case   4: c += 2;
                break;
        }
    }
    printf("%d\n", c);
    return 0;
}
```

程序运行后的输出结果是（ ）
- A: 3
- B: 5
- C: 7
- D: 9

**正确答案**：A  
**官方解析**：  
让我们逐步分析这段代码的执行过程：

第一次循环(k=1):  
- k=1时进入switch语句  
- 由于没有case 1，执行default分支  
- c += k 使得 c = 0 + 1 = 1  
- 之后会继续执行case 2(因为switch的特性)  
- c++ 使得 c = 2  
- 遇到break跳出switch  

第二次循环(k=2):  
- k=2时进入switch语句  
- 直接执行case 2  
- c++ 使得 c = 3  
- 遇到break跳出switch  

k=3时循环条件不满足，结束循环。  
所以最终c的值为3。

A选项3是正确答案。

分析其他选项错误原因：  
- B(5)错误：没有正确理解switch语句的执行流程，特别是default后面会继续执行其他case的特点  
- C(7)错误：可能误以为每次循环都会执行多个case  
- D(9)错误：严重高估了累加的次数  

这道题的关键点是：  
1. switch语句如果没有break，会继续执行下一个case  
2. default分支不一定在最后，执行完default后如果没有break会继续执行后续case  
3. 循环次数只有2次(k=1和k=2)  

“无匹配时找 default，从哪进就从哪走，只下不上不回头。”  

**知识点**：C++、C语言

---

### 4. 在下列的符号常量定义中，正确的定义格式为（ ）?

- A: #define M1
- B: const int M2 20;
- C: #define M3 10
- D: const char mark;

**正确答案**：C  
**你的答案**：D  
**官方解析**：  
在C语言中定义符号常量需要遵循特定的语法规则。C选项 `#define M3 10` 是完全正确的预处理器宏定义格式。

分析各选项：  
- A: `#define M1` 是不完整的宏定义，缺少了要定义的值。宏定义必须包含名称和对应的值。  
- B: `const int M2 20;` 语法错误。正确的const常量定义应该是 `const int M2 = 20;`，需要使用赋值符号`=`。  
- C: `#define M3 10` 正确：以`#define`开头，后跟宏名称和替换值，格式完整且符合语法规则。  
- D: `const char mark;` 是不完整的常量声明，没有初始化值。const常量必须在声明时进行初始化。  

---

### 5. 下面关于#import和#include描述正确的是

- A: #import和#include不可以混合使用
- B: #import只用于引用Objective-C的文件，#include只用于Ｃ和C++的文件
- C: #import和#include的使用效果完全相同
- D: #import是#include的替代指令，防止重复引用

**正确答案**：D  
**你的答案**：B  
**官方解析**：  
`#import`和`#include`是C/C++/Objective-C中常用的预处理指令。D选项正确，因为`#import`确实是`#include`的替代指令，主要优势在于可以防止头文件的重复引用。当使用`#import`时，即使同一个头文件被引用多次，编译器也只会包含一次，避免由重复包含导致的编译错误。

分析其他选项：  
- A错误：`#import`和`#include`可以混合使用，它们并不互斥。在混合使用Objective-C和C++的项目中常同时使用。  
- B错误：说法过于绝对。虽然Objective-C开发中更常用`#import`，C/C++开发中更常用`#include`，但两种指令都可引用各种类型头文件。  
- C错误：使用效果不完全相同。主要区别是`#import`具有防止重复引用的特性，而`#include`没有。  

补充说明：`#import`通过`#pragma once`机制确保每个头文件只被包含一次，在大型项目中可提高编译效率，减少出错可能性。  

**知识点**：C++、C语言

---

### 6. 下列描述错误的是:

- A: 在创建对象前，静态成员不存在
- B: 静态成员是类的成员
- C: 静态成员不能是虚函数
- D: 静态成员函数不能直接访问非静态成员

**正确答案**：A  
**官方解析**：  
在C++中，静态成员是类级别的成员，它们在程序启动时就已经存在，不依赖于对象的创建。因此A选项说"在创建对象前，静态成员不存在"是错误的。静态成员的生命周期从程序开始运行时就开始了，直到程序结束。

---

### 7. 以下不正确的定义语句是（ ）

- A: double x[5] = {2.0, 4.0, 6.0, 8.0, 10.0};
- B: char c2[] = {'\x10', '\xa', '\8'};
- C: char c1[] = {'1','2','3','4','5'};
- D: int y[5+3]={0, 1, 3, 5, 7, 9};

**正确答案**：B  
**官方解析**：  
B选项中的字符数组定义存在问题：  
- `\x10` 是合法的十六进制转义字符（十进制16）  
- `\xa` 是合法的十六进制转义字符（十进制10）  
- `\8` 是非法的八进制转义字符（八进制数字必须在0-7之间，8超出范围）

---

### 8. 分析一下这段程序的输出

```cpp
#include<iostream>
using namespace std;
class B {
public:
    B() { cout << "default constructor" << " "; }
    ~B() { cout << "destructed" << " "; }
    B(int i): data(i) { cout << "constructed by parameter" << data << " "; } 
private: 
    int data;
}; 
B Play(B b) { return b; } 
int main() {
    B temp = Play(5);
    return 0;
}
```

- A: constructed by parameter5 destructed destructed
- B: constructed by parameter5 destructed
- C: default constructor constructed by parameter5 destructed
- D: default constructor constructed by parameter5 destructed destructed

**正确答案**：A  
**你的答案**：B  
**官方解析**：  
代码执行流程分析：  
1. `Play(5)`调用时：  
   - 参数5触发`B(int)`构造函数，输出`constructed by parameter5`  
   - 形参`b`接收临时对象  
   - 函数返回时创建临时返回对象（编译器优化省略拷贝构造）  
   - 形参`b`析构，输出`destructed`  
2. 赋值给`temp`时：  
   - `temp`直接使用返回的临时对象（编译器优化）  
   - `main`结束时`temp`析构，输出`destructed`  

完整输出序列：`constructed by parameter5 destructed destructed`  

错误选项分析：  
- B错误：缺少`temp`对象的析构输出  
- C/D错误：不会触发默认构造函数  

关键点：理解临时对象生命周期和编译器返回值优化（RVO）机制。  

**知识点**：C++

---

### 9. STL中的一级容器有:

- A: vector, deque, list, set, multiset, map, multimap.
- B: 序列容器，关联容器，容器适配器
- C: set, multiset, map, multimap.
- D: vector, deque, list.

**正确答案**：D  
**你的答案**：A  
**官方解析**：  
STL中最基本的一级容器是：  
- **vector**：动态数组，支持随机访问  
- **deque**：双端队列，支持两端高效插入/删除  
- **list**：双向链表，支持双向遍历  

错误选项分析：  
- A错误：混合了一级容器（vector/deque/list）和二级容器（set/map等关联容器）  
- B错误：描述的是容器分类（序列/关联/适配器），非具体容器类型  
- C错误：set/map等是关联容器，属于二级容器  

关键点：一级容器是基础数据结构实现，其他容器在其上构建。  

---

### 10. 下面有关c++线程安全，说法错误的是？

- A: 线程安全问题一般是由全局变量及静态变量引起的
- B: 若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全
- C: c++标准库里面的string保证是线程安全的
- D: POSIX线程标准要求C标准库中的大多数函数具备线程安全性

**正确答案**：C  
**官方解析**：  
C++标准库中的`std::string`**不保证线程安全**。多线程并发访问同一string对象（至少一个写操作）可能导致数据竞争，需手动添加同步机制。

其他选项分析：  
- A正确：线程安全问题主要源于共享资源（全局/静态变量、局部静态变量、堆对象等）的并发访问  
- B正确：只读访问共享数据通常安全；写操作需同步机制（如互斥锁）  
- D正确：POSIX标准要求C标准库大多数函数具备线程安全性（通过线程本地存储等机制实现）  

**知识点**：C++
