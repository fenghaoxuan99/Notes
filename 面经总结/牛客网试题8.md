

## 1.
有以下程序

```c
int main() {  
    char a[7] = "a0\0a0\0";
    int i, j;
    i = sizeof(a); 
    j = strlen(a);
    printf("%d  %d\n",i, j);
}
```

程序运行后的输出结果是（）

- **A:** 2 2  
- **B:** 7 6  
- **C:** 7 2  
- **D:** 6 2  

**正确答案：C**  
**你的答案：B**  

**官方解析：**  
这道题目考察了C语言中数组、字符串、sizeof和strlen函数的基本概念。

分析数组 a[7] = "a0a0" 的情况：
1. sizeof(a)的值为7：因为sizeof计算的是数组a的总大小，而数组a被声明为char a[7]，所以结果就是7字节。
2. strlen(a)的值为2：strlen计算的是字符串的长度，它从字符串开始计数直到遇到第一个'\0'为止。在这个数组中，内容为"a0a0"，从开始到第一个'\0'只有"a0"两个字符，所以长度为2。

---

## 2.
下面程序执行结果:

```cpp
using namespace std;
class A{
    public:
        virtual void f() { cout << "A::f() "; }
        void f() const { cout << "A::f() const "; }
};
class B : public A {
    public:
        void f() { cout << "B::f() "; }
        void f() const { cout << "B::f() const "; }
};
void g(const A* a) {
    a->f();
}
int main(int argc, char *argv[]) {
    A* p = new B();
    p->f();
    g(p);
    delete(p);
    return 0;
}
```

- **A:** B::f() B::f() const  
- **B:** B::f() A::f() const  
- **C:** A::f() B::f() const  
- **D:** A::f() A::f() const  

**正确答案：B**  
**你的答案：A**  

**官方解析：**  
这道题目考察了C++中虚函数、常函数以及多态的概念。

p->f()调用输出"B::f()"：因为p是A类型的指针指向B类对象，而f()是虚函数，会发生动态绑定，调用B类的f()。

g(p)调用输出"A::f() const"：当p作为参数传入g函数时，参数类型是const A*，这会调用const版本的f()函数。虽然A::f() const不是虚函数，但即使是B对象，也会调用基类A的const成员函数。

所以最终输出结果是"B::f() A::f() const"，B选项正确。

分析其他选项：
- A错误：第二次调用不会输出"B::f() const"，因为const A*类型的参数会调用A类的const成员函数
- C错误：第一次调用不会输出"A::f()"，因为虚函数会动态绑定到B类的函数
- D错误：两次都不会调用A类的函数，第一次会动态绑定到B类函数，第二次因为是const成员函数所以调用A类的const版本

这个题目的关键点在于理解：
1. 虚函数的动态绑定特性
2. const成员函数和非const成员函数的调用规则
3. 指针类型对函数调用的影响

---

## 3.
关于类模板，描述错误的是（ ）？

- **A:** 一个普通基类不能派生类模板  
- **B:** 类模板可以从普通类派生，也可以从类模板派生  
- **C:** 根据建立对象时的实际数据类型，编译器把类模板实例化为模板类  
- **D:** 函数的类模板参数需生成模板类并通过构造函数实例化  

**正确答案：A**  
**你的答案：C**  

**官方解析：**  
A选项描述错误。普通基类是可以派生出类模板的,这是C++类继承的基本特性之一。普通类完全可以作为基类派生出类模板。

分析其他选项:
- B选项正确:类模板具有灵活的继承特性,既可以从普通类派生,也可以从其他类模板派生。这体现了类模板的继承多样性。
- C选项正确:类模板是一种模板,需要根据实际使用时指定的具体数据类型,由编译器进行实例化生成对应的模板类。这是类模板实例化的基本机制。
- D选项正确:当函数参数涉及类模板时,需要先根据实际类型实例化出具体的模板类,再通过构造函数完成实例化。这是函数使用类模板参数的标准流程。

总结:类模板是C++中一种重要的泛型编程机制,具有灵活的继承关系,可以从普通类派生也可以作为派生类。题目中只有A选项的说法与C++语言特性不符。

---

## 4.
调用recv(int sockfd, void *buf, size_t len, int flags)的过程中，一共进行了几次内存复制操作？

- **A:** 1  
- **B:** 2  
- **C:** 3  
- **D:** 4  

**正确答案：B**  

**官方解析：**  
recv函数在接收网络数据时会发生2次内存复制操作,具体过程如下:

第1次复制:数据从网卡通过DMA(直接内存访问)被复制到内核空间的缓冲区中。

第2次复制:数据从内核空间的缓冲区被复制到用户空间的缓冲区(即recv函数参数buf指向的内存空间)中。

这两次复制是必要的,因为:
1. 出于安全考虑,用户程序不能直接访问网卡和内核空间
2. 内核空间和用户空间是隔离的,需要通过复制在它们之间传递数据

---

## 5.
下面程序输出结果是什么?

```cpp
#include<iostream>
using namespace std;
class A{
public:
    A(char *s)
    {
        cout<<s<<endl;
    }
    ~A(){}
};
class B:virtual public A
{
public:
    B(char *s1,char*s2):A(s1){
        cout<<s2<<endl;
    }
};
class C:virtual public A
{
public:
    C(char *s1,char*s2):A(s1){
        cout<<s2<<endl;
    }
};
class D:public B,public C
{
public:
    D(char *s1,char *s2,char *s3,char *s4):B(s1,s2),C(s1,s3),A(s1)
    {
        cout<<s4<<endl;
    }
};
int main() {
    D *p=new D("class A","class B","class C","class D");
    delete p;
    return 0;
}
```

- **A:** class A class B class C class D  
- **B:** class D class B class C class A  
- **C:** class D class C class B class A  
- **D:** class A class C class B class D  

**正确答案：A**  

**官方解析：**  
这道题目考察了C++中虚继承和构造函数的调用顺序。选项A是正确的，输出顺序为"class A"、"class B"、"class C"、"class D"。

分析原因：
1. 在这个程序中，类B和类C都是虚继承自类A，类D同时继承自B和C。
2. 当使用虚继承时，构造函数的调用顺序遵循以下规则：
   - 首先调用虚基类的构造函数（这里是类A）
   - 然后按照声明顺序调用非虚基类的构造函数（这里是类B、类C）
   - 最后调用派生类的构造函数（这里是类D）
3. 虽然在B和C的构造函数中都包含了对A的构造函数的调用，但由于虚继承的特性，A的构造函数只会被调用一次，且是在最开始被调用。
