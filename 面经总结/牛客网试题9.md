5.
下面 C++ 代码的运行结果是（）

#include <iostream>
 
using std::cout;
using std::endl;
using std::move;
 
struct Test {  
    Test() = default;
    Test(const Test& that) {
      cout << "copy constructor" << endl;
    }
    Test& operator=(const Test& rhs) {
      cout << "copy assignment operator" << endl;
      return *this;
    }
};
 
int main() {
  Test a, b;
  a = b;
  Test c = move(b);
  return 0;
}
A
copy assignment constructor, copy constructor
B
copy assignment constructor, copy assignment operator
C
编译错误
D
运行错误
正确答案：A
你的答案：C
官方解析：
本题考察move和常左值引用，拷贝构造和拷贝运算符的用法。对于a = b来说，a是一个已经存在的左值，所以a = b会调用赋值构造函数，输出copy assignment constructor，对于Test c = move(b)，虽然move(b)是一个右值，但右值可以绑定到一个常左值引用上，但是c之前不存在，因此c = move(b) 会调用拷贝构造函数，输出copy constructor ，因此正确答案为B。
知识点：C++

4.
c++中下列哪个叙述是正确的？
A
成员变量的名字不可以和局部变量的名字相同。
B
方法的参数的名字可以和方法中声明的局部变量的名字相同。
C
成员变量没有默认值。
D
局部变量没有默认值。（静态局部变量除外）
正确答案：D
你的答案：B
官方解析：
在C++中，分析各选项的正确性如下：

选项a：错误。成员变量和局部变量可以同名，但需要通过this指针区分作用域。
选项b：错误。方法的参数和局部变量若在同一作用域内同名会导致编译错误（重复定义）。
选项c：错误。成员变量是否具有默认值取决于对象的初始化方式。例如：
静态存储期（如全局对象）或值初始化的对象（如new A()）的成员变量会被零初始化。
动态存储期的局部对象若未显式初始化，其基本类型成员变量值未定义。
因此，成员变量在某些情况下有默认值，选项c的表述不准确。
选项d：正确。普通局部变量没有默认值（值未定义），而静态局部变量会被初始化为零或默认构造。
正确答案：d.局部变量没有默认值。（静态局部变量除外）


5.
Which of following C++ code is correct?
A
int f() { int *a = new int(3); return *a; }
B
int *f() { int a[3] = {1, 2, 3}; return a; }
C
vector<int> f() {vector<int> v(3); return v; }
D
void f(int *ret) { int a[3] = {1, 2, 3}; ret = a++; return; }
正确答案：C
你的答案：A
官方解析：
这道题目考察了C++中函数返回值的正确使用方式。C选项是正确的,因为vector是C++标准库提供的容器类,它会自动管理内存,可以安全地通过值返回。当函数返回vector对象时,会调用拷贝构造函数创建一个新的vector对象。

分析其他选项的错误原因:

A错误:虽然可以编译通过,但存在内存泄漏。函数在堆上分配了内存(new int(3)),但只返回了这块内存中的值,没有释放内存,会导致内存泄漏。

B错误:试图返回局部数组的指针。局部数组a在函数结束时会被销毁,返回其地址会导致悬垂指针,这是未定义行为。

D错误:存在多个问题:
1. 试图将局部数组赋值给参数指针ret
2. 对数组使用++运算符是非法的
3. 即使去掉++,赋值给ret也只是修改了局部指针变量,不会影响调用者

正确的做法是使用vector这样的容器类(如C选项所示),或者使用智能指针来管理动态内存,避免使用裸指针和局部数组的返回。
知识点：C++、C语言


4.
以下关于STL的描述中，____是错的。
A
STL容器是线程不安全的
B
当容量不够时，STL的一个典型实现是vector内部内存扩展方式为翻倍
C
std::sort是稳定排序
D
std::bitset不是一个STL容器
E
std::stack默认是用deque实现的
F
std::string中可以存储多个’\0’字符
正确答案：C
你的答案：D
官方解析：
std::sort 不是稳定排序,它是不稳定的快速排序算法。如果需要稳定排序,应该使用 std::stable_sort。稳定排序算法保证相等元素的相对顺序在排序后保持不变,而std::sort为了追求性能,不保证这一点。

分析其他选项:

A正确:STL容器确实是线程不安全的。多线程环境下对同一个容器进行并发操作需要额外的同步机制。

B正确:vector的内存扩展策略通常是翻倍增长,这种策略在时间复杂度和空间利用率之间取得了较好的平衡。比如当前容量为100,满了之后会扩展到200。

D正确:std::bitset不是STL容器,它是一个固定大小的位集合。STL容器都支持迭代器,而bitset不支持迭代器,也不提供STL容器的常见接口如push_back等。

所以C选项说std::sort是稳定排序是错误的。在需要保持相等元素相对顺序的场景下,应该使用std::stable_sort而不是std::sort。
知识点：2015、C++、算法工程师、设计