# C++ 程序终止与异常处理机制详解

## 1. 基础类型与宏

### 1.1 std::nullptr_t

`std::nullptr_t` 是空指针字面量 `nullptr` 的类型，它是既**非指针类型亦非指向成员指针类型**的独立类型。

**使用示例**：
```cpp
void func(int* ptr) {
    std::cout << "Pointer to int\n";
}

void func(std::nullptr_t) {
    std::cout << "Null pointer\n";
}

int main() {
    int* ptr = nullptr;
    func(ptr);      // 输出: Pointer to int
    func(nullptr);  // 输出: Null pointer
}
```

### 1.2 std::size_t

`std::size_t` 是 `sizeof` 运算符返回的无符号整数类型，能够存放下理论上可能存在的对象的最大大小。

**关键特性**：
- 用于表示对象大小和数组索引
- 与容器中的 `size_type` 通常相同
- 足够大以存储任何非成员指针

**使用示例**：
```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};
    for (std::size_t i = 0; i < vec.size(); ++i) {
        std::cout << vec[i] << " ";
    }
    std::cout << "\n";
    
    std::size_t array_size = sizeof(int) * 10;
    std::cout << "Array size: " << array_size << "\n";
}
```

## 2. 程序终止相关函数

### 2.1 std::raise

发送信号给程序，调用相应的信号处理函数。

**常用信号常量**：

| 常量     | 解释                          |
|----------|-----------------------------|
| SIGTERM  | 发送给程序的终止请求             |
| SIGSEGV  | 非法内存访问(分段错误)           |
| SIGINT   | 外部中断，通常为用户所起始        |
| SIGILL   | 非法程序映像，例如非法指令         |
| SIGABRT  | 异常终止条件，如 std::abort() 所起始 |
| SIGFPE   | 错误算术运算，例如除以零          |

**示例代码**：
```cpp
#include <csignal>
#include <iostream>

void signal_handler(int signal) {
    switch(signal) {
        case SIGTERM: std::cout << "Termination request\n"; break;
        case SIGSEGV: std::cout << "Segmentation fault\n"; break;
        case SIGINT:  std::cout << "Interrupt signal\n"; break;
        default:      std::cout << "Unknown signal\n";
    }
}

int main() {
    // 安装多个信号处理函数
    std::signal(SIGTERM, signal_handler);
    std::signal(SIGSEGV, signal_handler);
    std::signal(SIGINT, signal_handler);
    
    std::cout << "Sending signals...\n";
    std::raise(SIGTERM);
    std::raise(SIGINT);
    
    // 模拟段错误
    // int* ptr = nullptr;
    // *ptr = 42;  // 这会触发 SIGSEGV
}
```

### 2.2 std::abort

导致不正常程序终止，不调用析构函数和已注册的退出函数。

**特点**：
- 立即终止程序
- 不执行清理操作
- 可以捕获 SIGABRT 信号进行自定义处理

**示例代码**：
```cpp
#include <csignal>
#include <iostream>

class ResourceHolder {
public:
    ResourceHolder() { std::cout << "Resource acquired\n"; }
    ~ResourceHolder() { std::cout << "Resource released\n"; }
};

void abort_handler(int) {
    std::cout << "Custom abort handler\n";
    // 注意：这里不应该尝试恢复执行
    std::_Exit(EXIT_FAILURE);
}

int main() {
    ResourceHolder holder;  // 析构函数不会被调用
    
    // 设置自定义 abort 处理
    std::signal(SIGABRT, abort_handler);
    
    std::cout << "Before abort\n";
    std::abort();  // 触发 SIGABRT
    std::cout << "After abort (unreachable)\n";
}
```

### 2.3 std::_Exit

导致程序终止而不清理资源。

**特点**：
- 不调用任何析构函数
- 不调用 atexit 或 at_quick_exit 注册的函数
- 立即终止程序

**示例代码**：
```cpp
#include <cstdlib>
#include <iostream>

class Test {
public:
    ~Test() { std::cout << "Test destructor\n"; }
};

Test global_test;  // 析构函数不会被调用

int main() {
    Test local_test;  // 析构函数不会被调用
    
    std::cout << "Calling _Exit\n";
    std::_Exit(EXIT_SUCCESS);
    std::cout << "This won't be printed\n";
}
```

## 3. 程序退出处理机制

### 3.1 std::atexit

注册在正常程序终止时调用的函数。

**特性**：
- 后注册的函数先执行
- 线程安全
- 若函数抛出异常，调用 std::terminate

**示例代码**：
```cpp
#include <cstdlib>
#include <iostream>

void cleanup1() { std::cout << "Cleanup 1\n"; }
void cleanup2() { std::cout << "Cleanup 2\n"; }
void cleanup3() { std::cout << "Cleanup 3\n"; }

int main() {
    // 注册顺序决定执行顺序（逆序）
    if (std::atexit(cleanup1) != 0) {
        std::cerr << "Failed to register cleanup1\n";
    }
    std::atexit(cleanup2);
    std::atexit(cleanup3);
    
    std::cout << "Main function executing\n";
    
    // 正常退出时会按 3, 2, 1 的顺序调用清理函数
    return 0;
    
    // 也可以用 std::exit(0) 触发同样行为
}
```

### 3.2 std::exit

正常终止程序，执行清理操作。

**执行顺序**：
1. 调用 atexit 注册的函数
2. 销毁静态存储期对象（逆序）
3. 销毁线程局部对象

**示例代码**：
```cpp
#include <cstdlib>
#include <iostream>

class Global {
public:
    Global() { std::cout << "Global constructed\n"; }
    ~Global() { std::cout << "Global destroyed\n"; }
};

Global global;

void exit_handler() {
    std::cout << "Exit handler\n";
}

int main() {
    std::atexit(exit_handler);
    
    std::cout << "Main function\n";
    
    // 触发退出处理
    std::exit(EXIT_SUCCESS);
    
    // 以下代码不会执行
    std::cout << "After exit\n";
}
```

### 3.3 std::quick_exit 和 std::at_quick_exit

快速终止程序，只执行特定清理。

**特点**：
- quick_exit 只调用 at_quick_exit 注册的函数
- 不调用 atexit 注册的函数
- 不执行完整的静态对象析构

**示例代码**：
```cpp
#include <cstdlib>
#include <iostream>

void quick_cleanup() {
    std::cout << "Quick exit cleanup\n";
}

void normal_cleanup() {
    std::cout << "Normal exit cleanup\n";
}

int main() {
    std::at_quick_exit(quick_cleanup);
    std::atexit(normal_cleanup);
    
    std::cout << "Main function\n";
    
    // 触发快速退出
    std::quick_exit(EXIT_SUCCESS);
    
    // 以下代码不会执行
    std::cout << "After quick_exit\n";
}
```

## 4. 断言机制

### 4.1 assert

运行时断言，在调试时检查条件。

**特点**：
- 定义在 <cassert>
- NDEBUG 宏会禁用 assert
- 失败时调用 abort

**示例代码**：
```cpp
#include <cassert>
#include <iostream>

int divide(int a, int b) {
    assert(b != 0 && "Division by zero");
    return a / b;
}

int main() {
    std::cout << divide(10, 2) << "\n";
    // 以下行在调试模式下会触发断言失败
    // std::cout << divide(10, 0) << "\n";
}
```

### 4.2 static_assert

编译时断言，检查类型或常量表达式。

**特点**：
- 不产生运行时开销
- 失败时编译错误
- C++11 引入，C++17 增强

**示例代码**：
```cpp
#include <type_traits>

template<typename T>
void process(T value) {
    static_assert(std::is_integral<T>::value, "T must be integral");
    // 处理逻辑...
}

struct POD {
    int x;
    double y;
};

static_assert(std::is_pod<POD>::value, "POD must be POD type");

int main() {
    process(42);    // OK
    // process(3.14); // 编译错误
}
```

## 5. 综合比较

| 函数/机制      | 调用析构函数 | 调用 atexit | 调用 at_quick_exit | 是否线程安全 | 适用场景 |
|---------------|-------------|------------|-------------------|-------------|---------|
| std::abort    | 否          | 否         | 否                | 是          | 严重错误立即终止 |
| std::_Exit    | 否          | 否         | 否                | 是          | 完全不清理的终止 |
| std::exit     | 是(静态)    | 是         | 否                | 是          | 正常程序终止 |
| std::quick_exit | 否        | 否         | 是                | 是          | 快速终止但有限清理 |
| return        | 是(局部)    | 是         | 否                | -           | main函数正常返回 |

## 6. 最佳实践建议

1. **资源管理**：
   - 优先使用 RAII 对象管理资源，而非依赖退出处理
   - 对于必须的清理操作，同时注册到 atexit 和 at_quick_exit

2. **错误处理**：
   - 对于可恢复错误使用异常
   - 对于不可恢复错误使用 abort 或 quick_exit

3. **多线程环境**：
   - 确保退出处理函数是线程安全的
   - 注意静态对象初始化的线程安全问题

4. **信号处理**：
   - 保持信号处理函数简单
   - 避免在信号处理函数中使用非异步安全函数

5. **断言使用**：
   - 使用 assert 检查不应发生的条件
   - 使用 static_assert 检查类型约束和编译期常量

**综合示例**：
```cpp
#include <cstdlib>
#include <iostream>
#include <csignal>
#include <cassert>

class DatabaseConnection {
public:
    DatabaseConnection() { std::cout << "Database connected\n"; }
    ~DatabaseConnection() { std::cout << "Database disconnected\n"; }
    void query() { std::cout << "Query executed\n"; }
};

void emergency_cleanup() {
    std::cout << "Performing emergency cleanup\n";
}

void normal_cleanup() {
    std::cout << "Performing normal cleanup\n";
}

void signal_handler(int sig) {
    std::cout << "Received signal: " << sig << "\n";
    std::quick_exit(EXIT_FAILURE);
}

int main() {
    // 注册清理函数
    std::atexit(normal_cleanup);
    std::at_quick_exit(emergency_cleanup);
    
    // 设置信号处理
    std::signal(SIGINT, signal_handler);
    std::signal(SIGTERM, signal_handler);
    
    DatabaseConnection db;
    db.query();
    
    // 编译时检查
    static_assert(sizeof(int) >= 4, "Requires 32-bit int");
    
    // 运行时检查
    int value = 42;
    assert(value > 0 && "Value must be positive");
    
    // 模拟正常退出
    // return EXIT_SUCCESS;
    
    // 模拟快速退出 (Ctrl+C 会触发类似行为)
    // std::quick_exit(EXIT_SUCCESS);
    
    // 模拟异常退出 (不会调用任何清理)
    // std::abort();
    
    return EXIT_SUCCESS;
}
```
