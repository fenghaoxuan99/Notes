## 链地址法操作详解

链地址法是哈希表解决冲突最常用的方法，其核心思想是将哈希到同一位置的元素组织成一个链表。以下是具体操作流程：

### 1. 插入操作
1. **计算哈希值**：对键进行哈希计算得到桶索引
   ```cpp
   size_t bucket_index = hash_func(key) % bucket_count;
   ```
2. **查找链表**：
   - 如果对应桶为空，直接创建新节点作为链表头
   - 如果非空，遍历链表检查是否已存在相同键
3. **插入节点**：
   - 键不存在时，将新节点插入链表头部(时间复杂度O(1))
   - 键存在时，更新对应节点的值

### 2. 查找操作
1. 计算键的哈希值确定桶位置
2. 遍历该桶对应的链表
3. 比较每个节点的键，找到匹配项则返回对应值

### 3. 删除操作
1. 计算键的哈希值定位桶
2. 遍历链表找到目标节点
3. 调整相邻节点的指针，移除目标节点
4. 释放目标节点内存

### 操作示例图示

初始状态：
```
桶数组: [0] -> null
       [1] -> null
       [2] -> null
```

插入键值对("apple",1):
1. hash("apple")=1 → 桶1
```
[1] -> ["apple":1] -> null
```

插入("banana",2)假设也哈希到1:
```
[1] -> ["banana":2] -> ["apple":1] -> null
```

查找"apple":
1. hash("apple")=1 → 遍历桶1链表
2. 比较"banana"≠"apple" → 下一个节点
3. "apple"=="apple" → 返回值1

### 时间复杂度分析
- 理想情况(无冲突)：O(1)
- 最坏情况(所有键哈希到同一桶)：O(n)
- 平均情况(良好哈希函数)：O(1 + α)，α为负载因子

### STL实现特点
1. 采用单链表而非双链表(节省内存)
2. 新元素插入链表前端而非尾部(避免遍历)
3. 桶数组通常使用vector实现
4. 节点结构包含键、值和next指针