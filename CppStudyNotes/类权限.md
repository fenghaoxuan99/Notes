# C++类成员访问权限全面指南

## 1. 访问权限基础概念

C++通过访问权限控制实现了面向对象编程的封装特性，提供了三种访问修饰符：

| 关键字    | 访问范围                                                                 |
|-----------|--------------------------------------------------------------------------|
| **public**    | 成员在类内、类外（通过对象）以及派生类中均可直接访问                   |
| **protected** | 成员在类内和派生类的成员函数中可访问，但类外不可访问                   |
| **private**   | 成员仅在类内（或友元）可访问，派生类和类外均不可直接访问              |

### 基础示例

```cpp
class BankAccount {
public:
    // 公有接口
    double getBalance() const { return balance; }
    void deposit(double amount) { 
        if (amount > 0) balance += amount; 
    }

protected:
    // 受保护成员，派生类可以访问
    void logTransaction(const std::string& type, double amount) {
        transactions.push_back({type, amount});
    }

private:
    // 私有成员，仅类内可访问
    double balance = 0;
    struct Transaction {
        std::string type;
        double amount;
    };
    std::vector<Transaction> transactions;
};

int main() {
    BankAccount account;
    account.deposit(100.0);  // 正确：调用公有成员函数
    // account.balance = 1000;  // 错误：无法直接访问私有成员
}
```

## 2. 继承方式与访问权限

继承方式决定了基类成员在派生类中的可见性：

| 继承方式      | 基类 `public` 成员 | 基类 `protected` 成员 | 基类 `private` 成员 |
|---------------|-------------------|----------------------|-------------------|
| **public**    | `public`          | `protected`          | 不可访问          |
| **protected** | `protected`       | `protected`          | 不可访问          |
| **private**   | `private`         | `private`            | 不可访问          |

### 继承示例

```cpp
class Vehicle {
public:
    void startEngine() { /* 启动引擎 */ }
protected:
    void checkFuel() { /* 检查燃料 */ }
private:
    void logEngineStart() { /* 记录启动日志 */ }
};

// 公有继承 - "is-a"关系
class Car : public Vehicle {
    // startEngine() 仍然是 public
    // checkFuel() 仍然是 protected
    // logEngineStart() 不可访问
};

// 保护继承 - 实现继承
class HybridVehicle : protected Vehicle {
    // startEngine() 变为 protected
    // checkFuel() 仍然是 protected
    // logEngineStart() 不可访问
};

// 私有继承 - 实现继承
class ElectricCar : private Vehicle {
    // startEngine() 变为 private
    // checkFuel() 变为 private
    // logEngineStart() 不可访问
};
```

## 3. protected成员的特殊规则

protected成员在派生类中有特殊访问规则：

```cpp
class Base {
protected:
    int value = 0;
};

class Derived : public Base {
public:
    void modifyValue(int newValue) {
        value = newValue;  // 正确：访问自己的基类protected成员
    }
    
    void modifyOtherDerived(Derived& other) {
        other.value = 10;  // 正确：访问同为派生类对象的protected成员
    }
    
    void modifyBase(Base& base) {
        // base.value = 20;  // 错误：不能通过基类对象访问protected成员
    }
};
```

## 4. 友元机制

友元可以突破访问权限限制，但应谨慎使用：

```cpp
class SecureContainer {
private:
    std::string secretData;
    
    // 声明友元类
    friend class SecurityInspector;
    
    // 声明友元函数
    friend void auditSecureContainer(const SecureContainer&);
};

class SecurityInspector {
public:
    void inspect(const SecureContainer& container) {
        std::cout << "Inspecting: " << container.secretData << std::endl;
    }
};

void auditSecureContainer(const SecureContainer& container) {
    std::cout << "Audit log: " << container.secretData << std::endl;
}

int main() {
    SecureContainer container;
    SecurityInspector inspector;
    inspector.inspect(container);  // 友元类可以访问私有成员
    auditSecureContainer(container);  // 友元函数可以访问私有成员
}
```

## 5. 默认访问权限与class/struct区别

| 特性        | class       | struct      |
|------------|------------|------------|
| 默认继承方式 | private    | public     |
| 默认成员访问 | private    | public     |
| 典型用途    | 封装复杂逻辑 | 数据聚合    |

### 示例对比

```cpp
// class示例
class PointClass {
    double x;  // 默认为private
    double y;
public:
    PointClass(double x, double y) : x(x), y(y) {}
    double distance() const { return std::sqrt(x*x + y*y); }
};

// struct示例
struct PointStruct {
    double x;  // 默认为public
    double y;
    double distance() const { return std::sqrt(x*x + y*y); }
};

// 继承差异
class DerivedClass : PointClass {  // 默认为private继承
    // PointClass的所有成员在此都是private
};

struct DerivedStruct : PointStruct {  // 默认为public继承
    // PointStruct的所有成员保持原访问权限
};
```

## 6. 访问权限调整技术

使用`using`声明可以调整派生类中基类成员的访问权限：

```cpp
class Base {
protected:
    void internalOperation() { /* 实现细节 */ }
};

class Derived : private Base {
public:
    // 将Base::internalOperation提升为public
    using Base::internalOperation;
    
    // 另一种方式：包装函数
    void publicOperation() {
        internalOperation();
        // 添加额外操作
    }
};

int main() {
    Derived d;
    d.internalOperation();  // 现在可以公开访问
    d.publicOperation();    // 替代方案
}
```

## 7. 实战应用与最佳实践

### 设计模式中的应用

```cpp
// 观察者模式中的访问控制
class Subject;

class Observer {
protected:
    // 受保护的update方法，只有Subject可以调用
    virtual void update(Subject* changedSubject) = 0;
    friend class Subject;  // 声明Subject为友元
};

class Subject {
private:
    std::vector<Observer*> observers;
protected:
    void notifyObservers() {
        for (auto obs : observers) {
            obs->update(this);  // 可以访问Observer的protected方法
        }
    }
public:
    void attach(Observer* obs) {
        observers.push_back(obs);
    }
    // ... 其他公有接口
};
```

### 模板类中的访问控制

```cpp
template <typename T>
class SmartPointer {
private:
    T* rawPtr;
    
    // 私有构造函数，只能由工厂方法调用
    explicit SmartPointer(T* ptr) : rawPtr(ptr) {}
    
public:
    ~SmartPointer() { delete rawPtr; }
    
    // 工厂方法
    template <typename... Args>
    static SmartPointer create(Args&&... args) {
        return SmartPointer(new T(std::forward<Args>(args)...));
    }
    
    // 公有接口
    T& operator*() const { return *rawPtr; }
    T* operator->() const { return rawPtr; }
    
private:
    // 禁用拷贝
    SmartPointer(const SmartPointer&) = delete;
    SmartPointer& operator=(const SmartPointer&) = delete;
};
```

## 8. 常见问题与解决方案

### 问题1：如何允许特定外部函数访问私有成员？

**解决方案**：使用友元函数而非将成员改为public

```cpp
class SecureData {
private:
    std::string data;
    
    // 只授予特定函数访问权限
    friend std::string getEncryptedData(const SecureData&);
};

std::string getEncryptedData(const SecureData& secure) {
    // 在此加密数据
    return "ENCRYPTED:" + secure.data;
}
```

### 问题2：派生类需要访问基类私有成员怎么办？

**解决方案**：使用protected访问方法而非直接暴露成员

```cpp
class Base {
private:
    int privateData;
    
protected:
    // 提供受保护的访问方法
    int getPrivateData() const { return privateData; }
    void setPrivateData(int value) { privateData = value; }
};

class Derived : public Base {
public:
    void processData() {
        int data = getPrivateData();  // 通过受保护方法访问
        // 处理数据...
    }
};
```

## 9. 总结与最佳实践

1. **最小权限原则**：成员应尽可能设置为private，只在必要时放宽限制
2. **public继承**：表示"is-a"关系时使用，确保派生类可以替代基类
3. **protected成员**：为派生类提供扩展点，但不暴露给外部
4. **友元机制**：谨慎使用，避免破坏封装性
5. **访问权限调整**：使用`using`声明或包装方法提供可控的访问

### 最终示例：完整的银行账户系统

```cpp
class BankAccount {
public:
    // 公有接口
    double getBalance() const { return balance; }
    
    void deposit(double amount) {
        if (amount > 0) {
            balance += amount;
            logTransaction("DEPOSIT", amount);
        }
    }
    
    bool withdraw(double amount) {
        if (amount > 0 && balance >= amount) {
            balance -= amount;
            logTransaction("WITHDRAW", amount);
            return true;
        }
        return false;
    }

protected:
    // 派生类可以扩展的功能
    virtual void logTransaction(const std::string& type, double amount) {
        // 基本实现
        transactions.push_back({type, amount, std::time(nullptr)});
    }

private:
    // 私有实现细节
    double balance = 0;
    
    struct TransactionRecord {
        std::string type;
        double amount;
        std::time_t timestamp;
    };
    
    std::vector<TransactionRecord> transactions;
    
    // 审计友元
    friend class BankAuditor;
};

class SavingsAccount : public BankAccount {
protected:
    // 覆盖日志记录，添加额外信息
    void logTransaction(const std::string& type, double amount) override {
        BankAccount::logTransaction(type, amount);
        // 添加储蓄账户特有的日志信息
        if (type == "WITHDRAW") {
            std::cout << "Savings account withdrawal recorded\n";
        }
    }
};

class BankAuditor {
public:
    void audit(const BankAccount& account) {
        std::cout << "Audit report:\n";
        std::cout << "Current balance: " << account.balance << "\n";
        // 可以访问account.transactions等私有成员
    }
};
```