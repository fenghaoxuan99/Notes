

### 1. 用户态 (User Mode)
*   **定义：** 应用程序（用户程序）运行时所处的特权级别较低的状态。
*   **特点：**
    *   **受限访问：** 只能访问分配给它的内存空间（用户空间）和有限的 CPU 指令集（非特权指令）。
    *   **硬件隔离：** 不能直接访问硬件设备（如磁盘、网卡、打印机）或执行特权指令（如直接操作内存管理单元 MMU、开关中断等）。
    *   **安全性：** 这是操作系统提供的核心保护机制。一个用户程序的错误（如野指针、死循环）或恶意行为通常无法直接影响其他程序或操作系统本身，因为它被限制在自己的“沙箱”里。
    *   **性能：** 执行用户态代码通常更快，因为不需要进行特权级别检查。

### 2. 内核态 (Kernel Mode / Supervisor Mode / Privileged Mode)
*   **定义：** 操作系统内核代码运行时所处的特权级别最高的状态。
*   **特点：**
    *   **完全访问：** 可以访问整个系统的物理内存、所有硬件资源，并执行所有 CPU 指令（包括特权指令）。
    *   **核心功能：** 负责执行操作系统的核心任务，如进程管理、内存管理、文件系统操作、设备驱动、网络通信、系统调用处理、中断处理等。
    *   **安全性关键：** 内核态代码必须高度可靠和安全，任何错误都可能导致整个系统崩溃（内核恐慌/蓝屏死机）。

### 3. 用户态 -> 内核态切换 (何时发生？)
用户程序无法直接执行内核代码或访问硬件。当它需要操作系统提供服务或响应外部事件时，必须**主动或被动**地触发从用户态到内核态的切换：

*   **系统调用 (System Call)：** 这是**最常见**的原因。应用程序通过特定的软件中断（如 `int 0x80`）或专门的指令（如 `syscall`/`sysenter`）发起一个请求。例如：
    *   读写文件 (`open`, `read`, `write`, `close`)
    *   创建新进程 (`fork`, `exec`)
    *   申请内存 (`brk`, `mmap`)
    *   网络通信 (`socket`, `connect`, `send`, `recv`)
    *   获取系统时间 (`gettimeofday`)
*   **中断 (Interrupt)：** 由**硬件设备**异步触发，通知 CPU 有事件需要处理（无论 CPU 当前在执行用户代码还是内核代码）。
    *   **外部硬件中断：** 如键盘按键、鼠标移动、网卡收到数据包、磁盘 I/O 完成、定时器到期（时钟中断）。
    *   **内部中断/异常 (Exception)：** 由 CPU 在执行指令时检测到的**错误或特殊情况**同步触发。
        *   **故障 (Fault)：** 通常可恢复，如缺页异常（访问未加载到物理内存的虚拟页）、除零错误、无效指令。
        *   **陷阱 (Trap)：** 故意引发的异常，通常用于调试（如断点 `int 3`）或系统调用（某些架构）。
        *   **中止 (Abort)：** 严重错误，通常导致进程终止，如硬件错误、非法内存访问（段错误/Segmentation Fault）。

### 4. 内核态 -> 用户态切换 (何时发生？)
*   **系统调用/中断/异常处理完成：** 当内核处理完一个系统调用请求、中断服务或异常后，需要将控制权交还给被打断的用户进程。
*   **进程调度：** 当内核决定切换到另一个用户进程执行时（例如当前进程时间片用完、更高优先级进程就绪、当前进程主动阻塞），在切换到目标用户进程之前，需要先返回到用户态执行该进程。

### 5. 切换的条件 (如何发生？)
*   **硬件机制：** CPU 提供专门的指令（如 `int`, `syscall`, `sysenter`）来触发软件中断/快速系统调用入口。
*   **中断描述符表 / 系统调用表：** CPU 在收到中断号或系统调用号时，会根据预先设置好的表（IDT - Interrupt Descriptor Table 或 Syscall Table）找到对应的内核处理函数的入口地址。
*   **特权级别检查：** CPU 在执行特权指令或访问受保护资源时，会检查当前的特权级别（CPL - Current Privilege Level）。如果权限不足（用户态），则触发异常（通常是通用保护错误）。
*   **上下文保存：** 在切换到内核态之前，CPU 硬件会自动将用户进程的关键上下文（如程序计数器 PC/指令指针 EIP/RIP、代码段寄存器 CS、标志寄存器 EFLAGS/RFLAGS、栈指针 ESP/RSP）压入**内核栈**（每个进程在内核空间有自己独立的内核栈）。这为后续返回用户态提供了基础。
*   **模式切换：** CPU 将当前特权级别设置为内核态（Ring 0）。
*   **跳转执行：** CPU 开始执行内核中对应的中断/异常/系统调用处理程序。

### 6. 上下文切换 (Context Switch)
*   **定义：** 指操作系统内核将 CPU 从一个正在运行的**进程（或线程）** 切换到另一个就绪的**进程（或线程）** 的过程。它保存当前进程的状态（上下文），并恢复目标进程之前保存的状态，使其得以继续执行。
*   **关键点：**
    *   **对象：** 发生在**进程或线程**之间。
    *   **内容：** 保存和恢复的“上下文”非常**全面**，包括：
        *   用户寄存器的值（通用寄存器如 EAX/RAX, EBX/RBX...，程序计数器 PC/EIP/RIP，栈指针 ESP/RSP 等）。
        *   内存管理单元（MMU）相关的状态（如页表基址寄存器 CR3 - 这决定了虚拟内存映射）。
        *   浮点寄存器状态（FPU）。
        *   其他与进程相关的内核状态（如打开的文件描述符表、信号处理信息、调度信息等）。
    *   **触发原因：**
        *   进程主动放弃 CPU（如调用 `sleep`, `wait`, 阻塞的 I/O 操作）。
        *   进程时间片用完（时钟中断触发调度）。
        *   更高优先级的进程就绪。
        *   进程终止。
    *   **开销：** 上下文切换是相对**昂贵**的操作，因为它需要保存/恢复大量寄存器状态，可能导致 CPU 缓存（Cache）和转换后备缓冲器（TLB）失效，从而影响性能。优化上下文切换是操作系统设计的重要目标。
*   **与用户态/内核态切换的关系：**
    *   **上下文切换通常涉及用户态/内核态切换：** 调度器代码运行在内核态。当决定进行上下文切换时，内核需要：
        1.  将当前进程从运行状态移出（可能变为就绪或阻塞）。
        2.  保存当前进程的完整上下文到其进程控制块（PCB）中。
        3.  选择下一个要运行的进程。
        4.  恢复该进程的上下文（包括其用户态寄存器、页表等）。
        5.  将 CPU 切换到用户态，开始执行目标进程。
    *   **用户态/内核态切换不一定导致上下文切换：** 例如，一个进程执行一个简单的系统调用（如 `getpid`），处理完后内核直接返回到同一个进程的用户态继续执行，没有发生进程切换。这只是一个**模式切换**（Mode Switch），开销远小于上下文切换。

### 总结

*   **用户态：** 应用程序的“沙箱”，权限低，安全。
*   **内核态：** 操作系统的“核心”，权限高，负责关键任务。
*   **切换 (用户->内核)：** 由系统调用、中断、异常触发，硬件自动保存部分上下文并跳转到内核处理程序。
*   **切换 (内核->用户)：** 内核处理完成或调度新进程时发生。
*   **上下文切换：** 内核在不同**进程/线程**间切换 CPU 使用权，需要保存和恢复完整的进程状态（上下文），开销较大，通常伴随用户态/内核态切换。