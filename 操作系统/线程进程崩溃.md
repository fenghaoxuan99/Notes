
# 线程崩溃了，进程也会崩溃吗？

## 线程崩溃与进程崩溃的关系
- 在 C/C++ 中，线程崩溃通常会导致进程崩溃。  
- 在 Java 中，线程崩溃（如 `StackOverflowError` 或 `NullPointerException`）**不会**导致 JVM 进程崩溃。  

### 为什么 C/C++ 中线程崩溃会引发进程崩溃？
线程共享进程的地址空间。非法内存访问（如以下情况）会触发 **Segment Fault**，操作系统为保护进程稳定性会终止整个进程：  
1. **向只读内存写入数据**  
   ```c
   char *s = "hello world";
   s[1] = 'H'; // 崩溃：尝试修改只读内存
   ```  
2. **访问无权限的地址空间**（如内核空间）  
   ```c
   int *p = (int *)0xC0000fff;
   *p = 10; // 崩溃：无权限写入内核空间
   ```  
3. **访问不存在的内存**  
   ```c
   int *a = NULL;
   *a = 1; // 崩溃：解引用空指针
   ```  

## 进程崩溃机制：信号（Signal）
操作系统通过**信号机制**终止进程：  
1. 执行 `kill -9 pid` 命令时，内核向进程发送信号（如 `SIGSEGV`）。  
2. 进程收到信号后暂停执行，控制权转交操作系统。  
3. 操作系统执行默认信号处理程序（通常终止进程）。  

### 进程如何避免崩溃？
进程可**自定义信号处理函数**或**忽略信号**（除 `kill -9`）：  
```c
#include <signal.h>
// 自定义处理函数
void sigHandler(int sig) {
    printf("Signal %d catched!\n", sig);
    exit(sig);
}
int main() {
    signal(SIGSEGV, sigHandler); // 捕获 SIGSEGV 后退出
    int *p = (int *)0xC0000fff;
    *p = 10; 
}
```  
```c
#include <signal.h>
int main() {
    signal(SIGSEGV, SIG_IGN); // 忽略 SIGSEGV
    raise(SIGSEGV);           // 发送信号
    printf("正常结束");       // 继续执行
}
```  

## 为什么 JVM 中线程崩溃不会导致进程崩溃？
JVM **自定义了信号处理函数**，拦截 `SIGSEGV` 信号并处理以下错误：  
- **`StackOverflowError`**：线程栈溢出（默认栈大小 8MB）。  
- **`NullPointerException`**：空指针访问。  

### OpenJDK 源码关键逻辑
```cpp
JVM_handle_linux_signal(int sig, ...) {
    if (sig == SIGSEGV) {
        // 1. 检查是否栈溢出
        if (addr < thread->stack_base() && addr >= thread->stack_base() - thread->stack_size()) {
            stub = SharedRuntime::continuation_for_implicit_exception(..., STACK_OVERFLOW);
        }
        // 2. 检查是否空指针
        else if (MacroAssembler::needs_explicit_null_check(...)) {
            stub = SharedRuntime::continuation_for_implicit_exception(..., IMPLICIT_NULL);
        }
    }
    if (stub != NULL) {
        return true; // 恢复线程执行，不终止 JVM
    }
    // 未处理的信号：生成 hs_err_pid_xxx.log 并退出
    VMError::report_and_die(); 
}
```  
- JVM 内部恢复 `StackOverflowError` 和 `NullPointerException`，将其转换为 Java 异常。  
- 未处理的信号会触发 JVM 退出（生成崩溃日志 `hs_err_pid_xxx.log`）。  

## 总结
| 场景         | 结果      | 原因      |
|-------------|-----------|----------------------------------|
| **C/C++ 线程崩溃** | 进程终止   | 操作系统默认处理 `SIGSEGV`，终止进程以保证稳定性。               |
| **JVM 线程崩溃**   | 进程存活   | JVM 拦截信号并恢复线程，抛出 Java 异常（工程健壮性考虑）。         |
| **未处理信号**     | JVM 退出  | 生成崩溃日志 `hs_err_pid_xxx.log`（如非法访问未被 JVM 捕获的内存）|  
