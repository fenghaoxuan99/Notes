
### **一、用户态和内核态**
1. **用户态和内核态的区别？**  
   - **内核态**：CPU 可执行所有指令，直接访问硬件资源（如内存管理、进程管理）。  
   - **用户态**：CPU 仅能执行部分指令，无法直接访问硬件，用于运行用户程序。  
   - **设计原因**：安全性（防止恶意程序破坏系统）、稳定性（用户程序崩溃不影响系统）、隔离性（内核与用户程序边界清晰）。

---

### **二、进程管理**
#### **1. 进程与线程**
1. **线程和进程的区别？**  
   - **本质**：进程是资源分配的基本单位；线程是任务调度的基本单位。  
   - **开销**：进程切换开销大（独立内存）；线程切换开销小（共享进程资源）。  
   - **稳定性**：线程崩溃可能导致进程崩溃；进程崩溃不影响其他进程。  
   - **内存**：进程独占内存；线程共享进程资源。

2. **进程、线程、协程的区别？**  
   - **进程**：独立内存空间，上下文切换开销大，稳定性高。  
   - **线程**：共享进程内存，需同步机制避免数据竞争，切换开销较小。  
   - **协程**：用户态轻量级线程，由程序控制调度，切换开销最小。

3. **为什么进程崩溃不影响其他进程？**  
   - **进程隔离**：每个进程有独立内存空间，崩溃后由操作系统回收资源。  
   - **独立性**：进程间不共享资源（如文件、网络连接）。

4. **进程的资源指什么？**  
   虚拟内存、文件句柄、信号量等。

5. **为何在进程下设计线程？**  
   - 解决多任务并发问题（如视频播放器的数据读取、解压、播放需并行）。  
   - 避免多进程通信开销，提高资源利用率。

#### **2. 多线程**
1. **多线程的优劣势？**  
   - **优势**：提高 CPU 利用率（多核）、加速程序执行。  
   - **劣势**：需处理数据竞争（锁机制）、死锁风险、资源消耗更大。

2. **多线程是否越多越好？**  
   否。过多线程会导致：  
   - 切换开销增大，占用大量内存/CPU。  
   - 竞争和死锁概率增加。

3. **进程切换 vs 线程切换？**  
   - **进程切换**：涉及内存、文件描述符等资源切换，开销大。  
   - **线程切换**：仅切换栈、寄存器等，开销小（因共享进程资源）。

4. **线程切换过程？**  
   - 保存当前线程上下文（寄存器、程序计数器）→ 切换到调度器 → 恢复新线程上下文 → 执行新线程。  
   - **上下文保存位置**：线程控制块（TCB）。

#### **3. 进程状态与调度**
1. **进程的五种状态及切换？**  
   - **状态**：创建 → 就绪 → 运行 → 阻塞 → 结束。  
   - **切换条件**：  
     - 就绪 → 运行：被调度器选中。  
     - 运行 → 阻塞：等待 I/O 等事件。  
     - 阻塞 → 就绪：事件完成。

2. **进程上下文包含什么？**  
   虚拟内存、栈、全局变量等用户空间资源 + 内核堆栈、寄存器等内核空间资源。

#### **4. 进程间通信（IPC）**
1. **IPC 方式有哪些？**  
   - 管道（匿名/命名）、消息队列、共享内存、信号、信号量、Socket。  
   - **匿名管道**：仅用于父子进程；**命名管道**：无关进程可通信。  
   - **共享内存实现**：映射相同物理内存到不同进程的虚拟地址空间。

2. **信号 vs 信号量？**  
   - **信号**：处理异步事件（如通知进程事件发生）。  
   - **信号量**：控制多进程/线程对共享资源的同步访问。

#### **5. 线程间通信**
- **方式**：互斥锁、读写锁、条件变量、自旋锁、信号量。  
- **应用场景**：  
  - 读写锁：读多写少场景（如缓存）。  
  - 自旋锁：临界区执行时间短的场景（避免线程切换）。

#### **6. 进程调度算法**
1. **常见算法**：  
   - 先来先服务（FCFS）  
   - 最短作业优先（SJF）  
   - 高响应比优先（HRRN）  
   - 时间片轮转（RR）  
   - 最高优先级（HPF）  
   - 多级反馈队列（综合 RR 和优先级，兼顾长短作业）。

---

### **三、锁机制**
1. **为何并发需加锁？**  
   防止竞态条件（多线程同时修改共享数据导致不一致）。

2. **自旋锁是什么？适用场景？**  
   - **原理**：加锁失败时循环忙等待（通过 CPU 的 CAS 指令实现）。  
   - **场景**：临界区执行时间短的场景（避免线程切换开销）。

3. **死锁的四个条件？**  
   互斥、持有并等待、不可剥夺、环路等待。

4. **如何避免死锁？**  
   - 破坏环路等待：资源有序分配（所有线程按相同顺序申请资源）。

5. **乐观锁 vs 悲观锁？**  
   - **乐观锁**：假设冲突少，更新时检查版本号（如 CAS）。  
   - **悲观锁**：假设冲突多，访问前先加锁（如互斥锁）。

---

### **四、内存管理**
1. **虚拟内存 vs 物理内存？**  
   - **虚拟内存**：进程独立的地址空间（大于物理内存）。  
   - **物理内存**：实际硬件内存。

2. **页表的作用？**  
   - 映射虚拟地址到物理地址（每页 4KB）。  
   - **缺页中断**：访问未映射的虚拟地址时触发，由操作系统分配物理页。

3. **写时复制（Copy on Write）**  
   - **原理**：`fork()` 时子进程共享父进程物理页；仅当修改时才复制新页。  
   - **优势**：节省物理内存，减少复制开销。

4. **`malloc(1KB)` vs `malloc(1MB)`？**  
   - `<128KB`：通过 `brk()` 在堆分配。  
   - `>128KB`：通过 `mmap()` 在文件映射区分配。

5. **内存不足时发生什么？**  
   - 触发内存回收：  
     - 后台回收（kswapd 线程异步回收）。  
     - 直接回收（同步阻塞进程）。  
   - 回收失败则触发 OOM Killer 终止占用内存高的进程。

6. **页面置换算法**  
   - OPT（理想算法）、FIFO、LRU（最近最少使用）、时钟算法、LFU（最不常用）。

---

### **五、中断**
1. **中断是什么？**  
   CPU 暂停当前任务处理紧急事件，完成后恢复原任务。

2. **中断流程？**  
   中断发生 → 保存上下文 → 执行中断处理程序 → 恢复上下文。

3. **中断类型？**  
   - **外部中断**：硬件触发（如设备 I/O）。  
   - **内部中断**：软件触发（如系统调用、缺页异常）。

---

### **六、网络 I/O**
1. **I/O 模型有哪些？**  
   - 阻塞 I/O、非阻塞 I/O、I/O 多路复用、信号驱动 I/O、异步 I/O。

2. **I/O 多路复用原理？**  
   单线程监听多个 Socket 事件（通过 `select`/`poll`/`epoll`）。

3. **`select`/`poll` vs `epoll`？**  
   - **`select/poll`**：线性扫描所有 Socket，效率低（O(n)）。  
   - **`epoll`**：红黑树存储 Socket + 事件回调机制，高效（O(1)）。

4. **边缘触发（ET） vs 水平触发（LT）？**  
   - **ET**：事件就绪时仅通知一次（需非阻塞 I/O + 一次性读完数据）。  
   - **LT**：事件就绪时重复通知，直到数据被处理。

5. **高性能服务器实现方式？**  
   - **Reactor 模式**：  
     - Redis（单 Reactor 单进程）。  
     - Netty（多 Reactor 多线程）。  
     - Nginx（多 Reactor 多进程 + 避免惊群）。

6. **零拷贝技术？**  
   - **传统 I/O**：4 次数据拷贝 + 4 次上下文切换。  
   - **零拷贝**：通过 `sendfile` 系统调用合并读写操作，仅需 2 次 DMA 拷贝，无 CPU 参与。