操作系统通过 **硬件支持的内存管理单元（MMU）** 和 **软件机制（如页表、段表）** 结合来判断进程访问的内存地址是否合法。
---

### 1. **虚拟地址与物理地址的映射**
   - 进程使用的是**虚拟地址**，由操作系统和MMU通过**页表**或**段表**将其转换为物理地址。
   - 每次内存访问时，CPU的MMU会自动查询页表：
     - 若虚拟地址无对应的物理页（页表项为空或无效），触发**缺页异常**（Page Fault）。
     - 若地址超出进程的虚拟地址空间范围（如访问未分配的地址），MMU直接判定为非法。

---

### 2. **权限检查**
   - 页表项（Page Table Entry, PTE）中存储了权限标志（如读/写/执行权限、用户/内核模式权限）。
   - 例如：
     - 用户进程尝试写入**只读页**（如代码段）→ 触发**段错误（Segmentation Fault）**。
     - 用户进程访问**内核空间地址**（高特权级页）→ 触发**保护异常**。

---

### 3. **操作系统的干预**
   - **缺页异常处理**：
     - 若地址合法但未分配物理页（如访问未初始化的堆空间），操作系统可能分配物理页或加载数据（如从磁盘换入）。
     - 若地址非法（如空指针解引用），操作系统终止进程（如Linux发送`SIGSEGV`信号）。
   - **系统调用边界检查**：
     - 当进程通过系统调用（如`read/write`）访问内存时，内核会验证用户传入的缓冲区地址是否属于该进程的合法空间（例如通过`access_ok()`函数检查）。

---

### 4. **硬件与软件协同的防护**
   - **MMU**：负责实时地址转换和权限检查（硬件加速）。
   - **操作系统**：维护页表、处理异常，并在进程创建时初始化合法的地址空间（如代码段、堆、栈等）。
   - **编译器/运行时**：在语言层面避免非法访问（如数组越界检查），但最终仍依赖硬件和OS的底层保护。

---

### 示例场景
- **合法访问**：进程访问已分配的堆内存（如`malloc`分配的地址）→ 页表存在有效映射 → 正常访问。
- **非法访问**：
  - 解引用`NULL`指针（地址`0x0`）→ 页表无映射 → 触发段错误。
  - 用户进程尝试修改内核代码段 → 权限不符 → 触发保护异常。

---

### 关键机制总结
| 机制               | 作用                                                                 |
|--------------------|----------------------------------------------------------------------|
| **页表/段表**      | 记录虚拟地址到物理地址的映射及权限（R/W/X, User/Kernel）。           |
| **MMU**            | 硬件实时检查地址转换和权限，触发异常。                               |
| **缺页异常处理**   | 操作系统动态分配内存或终止非法访问。                                 |
| **系统调用验证**   | 内核确保用户传入的指针指向合法内存（如`copy_from_user`）。           |

