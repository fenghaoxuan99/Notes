# CPU 缓存一致性

## CPU Cache 的作用与结构
- **背景**：CPU 与内存访问性能差距大，CPU Cache 作为高速缓存嵌入 CPU 核心附近，加速数据访问。
- **三级缓存**：
  - L1/L2 Cache：每个 CPU 核心独有。
  - L3 Cache：所有核心共享。
- **Cache Line**：CPU 从内存读取数据的基本单位，由标志位（Tag）和数据块（Data Block）组成。

---

## CPU Cache 数据写入策略
### 写直达（Write Through）
- **机制**：数据同时写入 Cache 和内存。
- **流程**：
  - 若数据在 Cache 中：更新 Cache → 写入内存。
  - 若数据不在 Cache 中：直接写入内存。
- **缺点**：每次写操作均需写内存，性能开销大。

### 写回（Write Back）
- **机制**：仅当 Cache Block 被替换时，才将脏数据写回内存。
- **流程**：
  - **命中 Cache**：更新数据，标记 Cache Block 为脏（Dirty）。
  - **未命中 Cache**：
    1. 若目标 Cache Block 为脏：先写回内存。
    2. 从内存加载数据到 Cache Block。
    3. 更新数据并标记为脏。
- **优点**：减少内存写入频率，提高性能。

---

## 多核缓存一致性问题
### 问题根源
- 多核心 CPU 的 L1/L2 Cache 私有化，导致各核心缓存数据可能不一致。
- **示例**：  
  核心 A 执行 `i++` 后未同步内存，核心 B 读取内存中的旧值 `i=0`，结果错误。

### 解决条件
1. **写传播（Write Propagation）**：核心更新 Cache 时，需广播事件至其他核心。
2. **事务串行化（Transaction Serialization）**：所有核心观察到数据操作的顺序必须一致。

---

## 一致性实现机制
### 总线嗅探（Bus Snooping）
- **原理**：核心更新 Cache 时，通过总线广播事件；其他核心监听总线并同步数据。
- **缺点**：广播加重总线负载，且无法保证事务串行化。

### MESI 协议
- **核心**：通过状态机管理 Cache Line 状态，降低总线压力并保证一致性。
- **四种状态**：
  | 状态          | 含义               | 数据一致性      |
  |------------- |-------------------|---------------|
  | Modified (M) | 数据已修改（脏数据）  | Cache ≠ 内存   |
  | Exclusive (E)| 数据独占（仅当前核心有| Cache = 内存   |
  | Shared (S)   | 数据共享（多核心共有）| Cache = 内存  |
  | Invalid (I)  | 数据失效（不可读）   | —             |

#### 关键行为
- **独占 → 共享**：其他核心读取相同数据时，状态从 `E` 转为 `S`。
- **共享写操作**：需广播使其他核心的 Cache Line 失效（→ `I`），再更新数据并标记为 `M`。
- **已修改写操作**：直接更新数据，无需广播。
- **脏数据替换**：`M` 状态 Cache Line 被替换前，必须写回内存。

---

## 总结
1. **Cache 优势**：CPU 优先读写 Cache 提升性能，未命中时从内存加载数据。
2. **写入策略**：
   - 写直达：简单但性能低（每次写内存）。
   - 写回：高性能（仅脏数据被替换时写内存）。
3. **多核一致性要求**：
   - 写传播 + 事务串行化。
4. **MESI 协议**：
   - 通过状态机（M/E/S/I）同步多核缓存。
   - `M` 和 `E` 状态写操作无需广播，减少总线压力。
