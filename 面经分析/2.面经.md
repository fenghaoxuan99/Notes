



有符号数的表示 int的大小

有符号数可以表示的范围

指针的大小 指针用完了怎么办（没太懂是说指针使用完成之后怎么办还是说指针都占用了内存空间怎么办？）

了解多线程吗

如果有两个进程或者是线程对一个变量（初值为0）各进行100次++操作 那么这个结果的范围是多少？

（2~200）

堆 排序 最大堆实现什么  排序 （从大到小还是从小到大）时间复杂度

讲一下网络模型

tcp建立连接的过程 写一下传递报文的主要信息

tcp和udp的区别



double 和float的大小  它们的存储形式

讲讲vector  如果需要扩大空间 是复制存储还是在原来的基础上直接扩大？

map和set是什么存储

unordered_map是什么存储 和map 的区别（其实也是 红黑树 和  哈希表 的区别？）

红黑树 和 哈希表  哪个占内存比较大？哪个初始化的时间比较大？

顶层const和底层const （举了几个具体的例子来分析）

希尔 排序 （不太了解）  那就讲一下快排

快排什么时候时间复杂度最高 为什么出现这种情况 怎么样数据初始化可以缓解这种情况（打乱，随机化数据）
### 1. 有符号数的表示及范围
```markdown
**考察点**：基础数据类型、二进制表示、补码知识

- **int大小**：通常为4字节(32位)，具体由编译器实现决定(C++标准只要求≥16位)
- **表示范围**：对于32位有符号int，范围是[-2³¹, 2³¹-1]即[-2147483648, 2147483647]
- **表示方法**：现代计算机普遍采用补码表示：
  - 最高位为符号位(0正1负)
  - 正数直接存储二进制值
  - 负数存储其绝对值的补码(按位取反+1)
```

### 2. 指针相关问题
```markdown
**考察点**：内存管理、指针本质

- **指针大小**：在32位系统为4字节，64位系统为8字节
- **使用后处理**：
  - 若指针对应动态内存：需手动delete/free防止内存泄漏
  - 若为栈指针：超出作用域自动回收
  - 最佳实践：使用智能指针(unique_ptr/shared_ptr)管理资源
```

### 3. 多线程同步问题
```markdown
**考察点**：并发编程、原子操作、竞态条件

- **结果范围分析**：
  - 无同步时：由于竞态条件，结果在[2,200]之间
  - 最小值2：线程1执行完所有++后线程2才开始
  - 最大值200：完美交替执行
- **解决方案**：
  1. 使用原子操作(std::atomic)
  2. 互斥锁(std::mutex)
  3. 内存屏障
```

### 4. 堆排序相关问题
```markdown
**考察点**：排序算法、堆数据结构

- **最大堆排序方向**：升序排序(从小到大)
- **实现步骤**：
  1. 构建最大堆(O(n))
  2. 反复取出堆顶元素并调整堆
- **时间复杂度**：
  - 建堆：O(n)
  - 排序：O(nlogn)
  - 总体：O(nlogn)
- **空间复杂度**：O(1)原地排序
```

### 5. 网络模型
```markdown
**考察点**：网络协议栈理解

- **OSI七层模型**：
  物理层→数据链路层→网络层→传输层→会话层→表示层→应用层
- **TCP/IP五层模型**：
  物理层→网络接口层→网络层(IP)→传输层(TCP/UDP)→应用层
```

### 6. TCP连接建立
```markdown
**考察点**：三次握手细节

- **三次握手过程**：
  1. SYN=1, seq=x (Client→Server)
  2. SYN=1, ACK=1, seq=y, ack=x+1 (Server→Client)
  3. ACK=1, seq=x+1, ack=y+1 (Client→Server)
- **关键字段**：
  - Sequence Number：序列号
  - Acknowledgment Number：确认号
  - SYN/ACK：控制标志位
```

### 7. TCP vs UDP
```markdown
**考察点**：传输层协议对比

| 特性        | TCP                  | UDP                  |
|-------------|----------------------|----------------------|
| 连接方式    | 面向连接             | 无连接               |
| 可靠性      | 可靠传输             | 尽最大努力交付       |
| 流量控制    | 滑动窗口             | 无                   |
| 拥塞控制    | 多种算法             | 无                   |
| 首部大小    | 20-60字节            | 8字节                |
| 传输效率    | 低                   | 高                   |
| 应用场景    | 文件传输、网页浏览   | 视频流、DNS查询      |
```

### 8. 浮点数存储
```markdown
**考察点**：IEEE 754标准

- **类型大小**：
  - float：4字节(32位)
  - double：8字节(64位)
- **存储格式**：
  [符号位][指数位][尾数位]
  - float：1-8-23
  - double：1-11-52
- **特殊值表示**：
  - 指数全1：无穷大/NaN
  - 指数全0：非规约数
```

### 9. vector扩容机制
```markdown
**考察点**：动态数组实现

- **扩容策略**：
  1. 分配新内存块(通常2倍增长)
  2. 拷贝所有元素到新内存
  3. 释放旧内存
- **时间复杂度**：
  - 均摊O(1)插入
  - reserve()可预分配减少拷贝
- **迭代器失效**：扩容会使所有迭代器失效
```

### 10. map/set实现
```markdown
**考察点**：关联容器实现

- **std::map/set**：
  - 红黑树实现
  - 有序存储
  - 操作复杂度：O(logn)
- **std::unordered_map/set**：
  - 哈希表实现
  - 无序存储
  - 平均O(1)操作
```

### 11. 红黑树 vs 哈希表
```markdown
**考察点**：数据结构选择

| 比较维度       | 红黑树                  | 哈希表                  |
|----------------|-------------------------|-------------------------|
| 内存占用       | 较小(仅存储指针)        | 较大(需预留桶空间)      |
| 初始化时间     | O(1)                    | O(n)构建哈希表          |
| 有序性         | 支持                    | 不支持                  |
| 最坏时间复杂度 | O(logn)                 | O(n)哈希冲突时          |
| 适用场景       | 需要有序访问/范围查询   | 需要快速点查询          |
```

### 12. const限定符
```markdown
**考察点**：类型系统理解

- **顶层const**：指针本身是常量
  ```cpp
  int* const p;  // p不可修改
  ```
- **底层const**：指向的对象是常量
  ```cpp
  const int* p;  // *p不可修改
  ```
- **应用实例**：
  ```cpp
  const int* const p; // 既是顶层又是底层const
  void foo(const string& s); // 底层const参数
  ```
```

### 13. 快速排序优化
```markdown
**考察点**：排序算法优化

- **最坏情况**：O(n²) 当分区极度不平衡时(如已排序数组选第一个元素为pivot)
- **优化方案**：
  1. 随机选择pivot
  2. 三数取中法
  3. 小数组切换为插入排序
  4. 双轴快排(Java Arrays.sort)
- **避免最坏情况**：
  ```cpp
  // 随机化选择pivot
  swap(arr[lo], arr[lo + rand() % (hi - lo + 1)]);
  ```
```
