# 单链表的快速排序实现分析

## 面试官考察点

作为面试官，我会从以下几个维度考察候选人对这个问题的理解：
1. 对快速排序算法的本质理解
2. 对链表特性的掌握程度
3. 算法实现能力
4. 时间/空间复杂度分析能力

## 快速排序在单链表上的可行性

**可以**，单链表可以使用快速排序，但实现方式与数组有所不同。

## 与数组快速排序的区别

| 特性        | 数组快速排序                     | 链表快速排序                     |
|------------|--------------------------------|--------------------------------|
| 分区操作    | 容易，可通过下标直接访问         | 需要遍历链表寻找分区点           |
| 交换元素    | O(1)时间交换                   | 需要修改指针，操作更复杂         |
| 递归实现    | 天然适合                       | 需要额外处理链表断开和连接       |
| 空间复杂度  | 最优O(log n)最差O(n)栈空间      | 最优O(log n)最差O(n)栈空间      |
| 时间复杂度  | 平均O(n log n)最差O(n²)        | 平均O(n log n)最差O(n²)        |

## 链表快速排序实现步骤

```cpp
// 链表节点定义
struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(nullptr) {}
};

// 获取链表尾节点
ListNode* getTail(ListNode* head) {
    while (head && head->next) {
        head = head->next;
    }
    return head;
}

// 分区函数
ListNode* partition(ListNode* head, ListNode* end, ListNode** newHead, ListNode** newEnd) {
    ListNode* pivot = end;
    ListNode *prev = nullptr, *cur = head, *tail = pivot;
    
    while (cur != pivot) {
        if (cur->val < pivot->val) {
            if (*newHead == nullptr) *newHead = cur;
            prev = cur;
            cur = cur->next;
        } else {
            if (prev) prev->next = cur->next;
            ListNode* tmp = cur->next;
            cur->next = nullptr;
            tail->next = cur;
            tail = cur;
            cur = tmp;
        }
    }
    
    if (*newHead == nullptr) *newHead = pivot;
    *newEnd = tail;
    return pivot;
}

// 快速排序主函数
ListNode* quickSort(ListNode* head, ListNode* end) {
    if (!head || head == end) return head;
    
    ListNode *newHead = nullptr, *newEnd = nullptr;
    ListNode* pivot = partition(head, end, &newHead, &newEnd);
    
    if (newHead != pivot) {
        ListNode* tmp = newHead;
        while (tmp->next != pivot) {
            tmp = tmp->next;
        }
        tmp->next = nullptr;
        
        newHead = quickSort(newHead, tmp);
        tmp = getTail(newHead);
        tmp->next = pivot;
    }
    
    pivot->next = quickSort(pivot->next, newEnd);
    return newHead;
}

// 对外接口
ListNode* sortList(ListNode* head) {
    return quickSort(head, getTail(head));
}
```

## 时间复杂度分析

- **最佳情况**：每次分区都能将链表均分，时间复杂度为O(n log n)
- **最坏情况**：链表已经有序，每次分区只能减少一个元素，时间复杂度为O(n²)
- **平均情况**：O(n log n)

## 空间复杂度分析

- 由于是递归实现，需要栈空间
- 最佳情况：O(log n)
- 最坏情况：O(n)

## 面试建议

1. 明确说明链表可以实现快速排序，但实现方式与数组不同
2. 解释清楚分区过程在链表上的实现难点
3. 能够分析时间/空间复杂度
4. 可以讨论替代方案（如归并排序更适合链表）
5. 注意代码实现的边界条件处理（空链表、单节点链表等）

## 扩展问题

面试官可能会进一步追问：
- 为什么归并排序在链表上更常用？
- 如何优化链表快速排序的性能？
- 非递归实现如何做？
- 如何选择pivot能提高性能？

希望这个分析对你准备面试有所帮助！