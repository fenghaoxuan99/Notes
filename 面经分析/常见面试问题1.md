
### C++ 常见面试问题整理与详解

---

#### **1. C++ 类的大小由哪些因素决定？**
类的大小受以下因素影响：
- **非静态成员变量**：所有非静态成员变量的大小总和（包括基类成员）。
- **内存对齐（Padding）**：编译器为满足内存对齐要求插入的额外字节（对齐规则：成员偏移量是其大小的整数倍，类总大小是最大对齐参数的整数倍）。
- **虚函数开销**：若类包含虚函数，会增加一个虚表指针（`vptr`，通常 4/8 字节）。
- **继承关系**：
  - 基类成员会占用派生类空间。
  - **虚继承**：为支持共享基类，引入虚基表指针（额外 4/8 字节）。
- **特殊规则**：
  - 空类大小为 **1 字节**（确保不同实例有唯一地址）。
  - 静态成员变量不占用类实例空间（存储在全局数据区）。
- **编译器优化**：如空基类优化（EBCO），允许基类子对象大小为 0。

**示例**：
```cpp
class Base {
    int a;         // 4 字节
    virtual void f(); // 引入 vptr (8 字节)
}; // 大小：4 + 4（对齐填充）+ 8 = 16 字节（64 位系统）

class Derived : public Base {
    char b;        // 1 字节
}; // 大小：Base(16) + 1 + 7（填充）= 24 字节
```

---

#### **2. 多态与虚函数实现**
- **多态**：同一接口在不同上下文中表现不同行为。C++ 通过**动态多态**（运行时多态）实现。
- **虚函数**：用 `virtual` 声明的成员函数，允许派生类重写。
- **实现机制**：
  1. **虚函数表（vtable）**：每个含虚函数的类有一个 vtable，存储虚函数指针。
  2. **虚表指针（vptr）**：每个对象隐含一个指向 vtable 的指针。
  3. **动态绑定**：通过 `vptr -> vtable -> 函数指针` 在运行时确定调用的函数。

**示例**：
```cpp
class Animal {
public:
    virtual void speak() { cout << "Animal sound" << endl; }
};
class Dog : public Animal {
public:
    void speak() override { cout << "Bark" << endl; } // 重写虚函数
};

Animal* a = new Dog();
a->speak(); // 输出 "Bark"（动态绑定）
```

---

#### **3. 析构函数与虚函数**
- **析构函数可为虚函数**：基类析构函数应声明为 `virtual`。
- **为什么需要虚析构函数**：  
  若通过基类指针删除派生类对象，非虚析构函数会导致**派生类析构未被调用**，引发资源泄漏。
- **必须使用虚析构的场景**：
  - 类作为基类使用。
  - 可能通过基类指针删除派生类对象（如 `Base* p = new Derived(); delete p;`）。

---

#### **4. RAII 与 shared_ptr**
- **RAII（Resource Acquisition Is Initialization）**：  
  资源生命周期绑定对象生命周期。构造函数获取资源，析构函数释放资源（如文件句柄、内存）。
- **shared_ptr 实现**：
  - **引用计数**：通过控制块（含引用计数、弱引用计数、删除器）。
  - **线程安全**：引用计数增减原子操作。
  - **内存结构**：  
    ```plaintext
    shared_ptr<int> sp -> [对象指针]  
                          [控制块指针] -> {引用计数, 弱引用计数, 删除器, 对象}
    ```
- **shared_ptr 可能内存泄漏**：
  - **循环引用**：  
    ```cpp
    class A { shared_ptr<B> b_ptr; };
    class B { shared_ptr<A> a_ptr; };
    auto a = make_shared<A>(); 
    auto b = make_shared<B>();
    a->b_ptr = b; 
    b->a_ptr = a; // 循环引用，计数永不归零
    ```
  - **解决**：用 `weak_ptr` 打破循环。

---

#### **5. new/delete 与 malloc/free 区别**
| **特性**               | **new/delete**                     | **malloc/free**               |
|------------------------|------------------------------------|-------------------------------|
| **语言**               | C++ 运算符                         | C 库函数                      |
| **内存初始化**         | 调用构造函数/析构函数              | 仅分配/释放内存               |
| **大小计算**           | 自动计算类型大小                   | 需手动指定字节数              |
| **失败行为**           | 抛出 `std::bad_alloc` 异常         | 返回 `NULL`                   |
| **重载**               | 可重载 `operator new/delete`       | 不可重载                      |
| **数组处理**           | 支持 `new[]/delete[]`              | 需手动计算数组大小            |
| **类型安全**           | 返回类型正确指针                   | 返回 `void*` 需强转           |

---

#### **6. 错误处理与异常禁用**
- **错误处理方法**：
  1. **返回错误码**（如 `int err = func()`）。
  2. **异常机制**（`try/catch/throw`）。
  3. **设置全局状态**（如 `errno`）。
  4. **断言**（`assert(condition)`，调试用）。
- **禁用异常的场景**：
  - **性能敏感系统**（如嵌入式、高频交易）：异常处理增加额外开销。
  - **实时系统**：异常导致执行时间不可预测。
  - **与 C 代码交互**：C 不支持异常，跨语言传递异常未定义。
  - **资源受限环境**：异常机制占用额外内存（异常表、栈展开信息）。

---

#### **7. 野指针（Dangling Pointer）**
指向无效内存的指针，常见场景：
1. **已释放的内存**：
   ```cpp
   int* p = new int(10);
   delete p; // p 成为野指针
   ```
2. **局部变量离开作用域**：
   ```cpp
   int* getPtr() {
       int x = 10;
       return &x; // 返回局部变量地址
   }
   ```
3. **未初始化的指针**：  
   `int* p;`（值随机，可能指向非法地址）。
4. **多次释放**：  
   `delete p; delete p;`（第二次操作时 p 已是野指针）。

---

#### **8. 悬垂引用（Dangling Reference）**
指向已销毁对象的引用：
```cpp
int& getRef() {
    int x = 10;
    return x; // 返回局部变量的引用
}
int& r = getRef(); // r 是悬垂引用
```
**与野指针区别**：引用必须初始化且不能重绑定，悬垂引用本质是“野引用”。

---

#### **9. 调试代码方法**
| **方法**                | **说明**                                                                 |
|-------------------------|--------------------------------------------------------------------------|
| **打印日志**            | 插入 `cout` 或日志库输出变量值、执行路径。                               |
| **调试器**              | GDB/LLDB（断点、单步执行、查看内存/寄存器）。                           |
| **断言**                | `assert(condition)` 快速捕获逻辑错误。                                  |
| **单元测试**            | 编写测试用例验证函数行为（如 Google Test）。                            |
| **内存检查工具**        | Valgrind（检测内存泄漏、越界访问）、AddressSanitizer。                  |
| **核心转储分析**        | 分析程序崩溃时的 `core dump` 文件。                                     |
| **IDE 可视化调试**      | VS/CLion 的图形化调试（监视变量、调用栈）。                             |
| **代码审查**            | 人工检查逻辑错误。                                                      |
| **二分注释法**          | 注释一半代码定位问题范围。                                              |
| **性能分析工具**        | perf、gprof 分析性能瓶颈。                                              |
| **版本控制比对**        | 用 `git bisect` 定位引入错误的提交。                                    |

---

### 总结
- **类大小**：成员变量、对齐、虚函数、继承共同决定。
- **多态**：虚函数通过 vtable/vptr 实现运行时绑定。
- **资源管理**：RAII 是核心，`shared_ptr` 需避免循环引用。
- **错误处理**：异常并非万能，需权衡性能与安全性。
- **调试**：结合日志、调试器、工具链多维度定位问题。
