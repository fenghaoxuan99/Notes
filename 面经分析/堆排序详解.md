# 堆排序详解

堆排序(Heap Sort)是一种基于二叉堆数据结构的比较排序算法。它利用堆的特性来高效地排序数据。

## 堆的基本概念

堆是一种特殊的完全二叉树，满足以下性质：
- 最大堆：每个节点的值都大于或等于其子节点的值
- 最小堆：每个节点的值都小于或等于其子节点的值

堆排序通常使用最大堆。

## 堆排序步骤

1. **构建最大堆**：将无序数组构建成一个最大堆
2. **排序阶段**：
   - 将堆顶元素(最大值)与最后一个元素交换
   - 减小堆的大小(排除已排序的部分)
   - 对新的堆顶元素执行"下沉"操作以恢复堆性质
3. 重复上述过程直到堆大小为1

## 关键操作：上浮(up)和下沉(down)

### 上浮(up)操作

当某个节点的值大于其父节点时(对于最大堆)，需要将该节点向上移动以维护堆性质。

```python
def up(heap, i):
    while i > 0 and heap[(i - 1) // 2] < heap[i]:
        heap[(i - 1) // 2], heap[i] = heap[i], heap[(i - 1) // 2]  # 交换父子节点
        i = (i - 1) // 2  # 移动到父节点位置
```

### 下沉(down)操作

当某个节点的值小于其子节点时(对于最大堆)，需要将该节点向下移动以维护堆性质。

```python
def down(heap, n, i):
    largest = i  # 初始化最大元素为当前节点
    left = 2 * i + 1  # 左子节点
    right = 2 * i + 2  # 右子节点
    
    # 找出当前节点、左子节点、右子节点中的最大值
    if left < n and heap[left] > heap[largest]:
        largest = left
    if right < n and heap[right] > heap[largest]:
        largest = right
    
    # 如果最大值不是当前节点，则交换并继续下沉
    if largest != i:
        heap[i], heap[largest] = heap[largest], heap[i]
        down(heap, n, largest)
```

## 完整堆排序实现

```python
def heap_sort(arr):
    n = len(arr)
    
    # 构建最大堆
    for i in range(n // 2 - 1, -1, -1):
        down(arr, n, i)
    
    # 逐个提取元素
    for i in range(n - 1, 0, -1):
        arr[0], arr[i] = arr[i], arr[0]  # 交换堆顶和当前最后一个元素
        down(arr, i, 0)  # 对新的堆顶执行下沉操作

# 下沉操作
def down(heap, n, i):
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2
    
    if left < n and heap[left] > heap[largest]:
        largest = left
    if right < n and heap[right] > heap[largest]:
        largest = right
    
    if largest != i:
        heap[i], heap[largest] = heap[largest], heap[i]
        down(heap, n, largest)

# 测试
arr = [12, 11, 13, 5, 6, 7]
heap_sort(arr)
print("排序后的数组:", arr)
```

## 时间复杂度分析

- 构建堆：O(n)
- 每次下沉操作：O(log n)，共执行n-1次
- 总时间复杂度：O(n log n)
- 空间复杂度：O(1)（原地排序）

堆排序是不稳定的排序算法，因为相同的元素在堆中可能被交换顺序。