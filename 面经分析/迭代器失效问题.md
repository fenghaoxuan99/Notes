在C++ STL（Standard Template Library）中，“**迭代器失效（iterator invalidation）**”是一个重要的概念，指的是某些操作（如插入、删除、重分配等）**可能导致已有的迭代器指向的对象不再有效**，从而使这些迭代器变成“野迭代器”，继续使用这些迭代器将导致**未定义行为（UB, Undefined Behavior）**。

---

### 一、迭代器失效的本质

迭代器本质上是容器中元素的一个“指针”或“代理对象”。当容器结构发生变化（如元素位置变动、容量扩展或缩小）时，之前获取的迭代器就可能不再指向原来的数据，**变得无效**。

---

### 二、各类 STL 容器的失效规则

以下为常用容器的迭代器失效情况汇总：

#### 1. **vector / deque**

| 操作             | 失效说明                                     |
| -------------- | ---------------------------------------- |
| `push_back`    | 若容量未扩展，则不失效；若扩展容量（即realloc），**所有迭代器失效**。 |
| `insert/erase` | **插入/删除会导致当前位置之后的迭代器全部失效。**              |
| `clear`        | 所有迭代器失效。                                 |

#### 2. **list（双向链表）**

| 操作             | 失效说明                           |
| -------------- | ------------------------------ |
| `insert/erase` | 只有被操作的那个元素的迭代器失效；**其他迭代器不失效！** |
| `clear`        | 所有迭代器失效。                       |

✅ `list` 是最安全的容器之一，插入删除不会影响其他迭代器。

#### 3. **set / map / multiset / multimap（红黑树）**

| 操作       | 失效说明                    |
| -------- | ----------------------- |
| `insert` | 迭代器不失效。                 |
| `erase`  | **只有被删除元素的迭代器失效**，其他不变。 |

✅ 和 `list` 类似，`set`/`map` 结构稳定，不会导致大面积迭代器失效。

#### 4. **unordered\_set / unordered\_map（哈希表）**

| 操作                   | 失效说明                            |
| -------------------- | ------------------------------- |
| `insert/erase`       | 可能导致**所有迭代器失效**，因为元素的重排/rehash。 |
| `rehash` 或 `reserve` | 会导致全部迭代器失效。                     |

⚠️ 使用 `unordered_xxx` 时应特别注意其扩容机制。

---

### 三、示例说明

```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> v = {1, 2, 3, 4};
    auto it = v.begin();

    v.push_back(5); // 如果此时vector扩容了，it将失效！

    std::cout << *it << std::endl; // ⚠️ 可能导致未定义行为！
}
```

---

### 四、避免迭代器失效的常见方法

* **谨慎使用容器修改操作**（如 `insert`, `erase`, `push_back`）；
* 如果必须修改容器，修改后**重新获取迭代器**；
* 对于可能失效的情况，使用 `list` / `map` 等**迭代器稳定的容器**；
* 使用 `std::advance()`、`std::next()` 等算法生成新的迭代器，而非长期持有一个旧的迭代器；
* C++11之后，可以使用 `auto` + `range-based for` 来避免直接操作迭代器。


在 C++ 的 STL（标准模板库）中，**迭代器失效**（Iterator Invalidation）指的是：某个操作（如插入、删除、重分配等）之后，原来指向容器中元素的迭代器、引用或指针不再安全使用，访问它们会导致未定义行为（undefined behavior）。

---

## 为什么会失效？

大多数容器为了高效地管理内存或维护内部结构，会在增删操作时进行如下操作：

1. **重新分配（Reallocation）**

   * 以 `vector` 为例，当容量（capacity）不足以容纳更多元素时，`vector` 会分配一块更大的内存，把旧数据搬到新地址，然后释放旧内存。结果是，原来指向旧内存区域的迭代器和引用都指向“悬空”地址。
2. **节点调整**

   * 在基于树或链表的容器（如 `map`、`set`、`list`）中，插入或删除元素会修改节点之间的指针关系，但并不搬迁已有节点的内存，因此失效规则更宽松或更可预测。

---

## 常见容器的失效规则

| 容器类型                | 插入操作                                                                                           | 删除操作                                | 重分配影响                |
| ------------------- | ---------------------------------------------------------------------------------------------- | ----------------------------------- | -------------------- |
| **vector**          | `push_back`、`emplace_back` 可能**全部失效**（若触发重分配）；否则，仅尾部插入前的迭代器有效。<br>`insert(pos, …)` 可能**全部失效**。 | `erase(pos)`：从 `pos` 开始到末尾的所有迭代器失效。 | 会触发重分配时，**所有迭代器**失效。 |
| **deque**           | `push_front`、`push_back`：对两端操作时，内部块可能重分配，导致**所有迭代器**失效。<br>`insert`：可能失效所有迭代器。                 | `erase`：仅在擦除点和末尾之间的迭代器失效。           | 块级重分配同样会失效迭代器。       |
| **list**            | `insert`、`push_…`：**不失效**任何迭代器（双向链表性质）。                                                        | `erase(it)`：仅 `it` 自身失效；其他迭代器安全。    | 不会整体重分配。             |
| **forward\_list**   | 同 `list`，但单链表。                                                                                 | 同 `list`。                           | 不会整体重分配。             |
| **map/set**         | `insert`：**不失效**已有迭代器（红黑树性质）。                                                                  | `erase(it)`：仅 `it` 自身失效；其他迭代器安全。    | 不会整体重分配。             |
| **unordered\_\*\`** | `insert`：若触发重哈希（rehash），**所有迭代器**失效；否则，插入前的迭代器仍然有效。                                            | `erase(it)`：仅 `it` 自身失效；其他迭代器安全。    | 重哈希时失效所有迭代器。         |
| **string**          | 类似于 `vector<char>`：插入、追加可能触发重分配，失效所有迭代器。                                                       | `erase`：从擦除位置到末尾的迭代器失效。             | 重分配时失效所有迭代器。         |

---

## 典型示例

```cpp
#include <vector>
#include <iostream>
using namespace std;

int main() {
    vector<int> v = {1, 2, 3};
    auto it = v.begin();     // it 指向 v[0]
    v.push_back(4);          // 可能触发重分配
    // 下面的 *it 就是未定义行为！
    cout << *it << endl;     
    return 0;
}
```

如果 `push_back` 没有触发重分配，`it` 依然有效；但如果触发了，`it` 就失效，访问 `*it` 会出错。

---

## 如何避免迭代器失效

1. **预先 `reserve`（针对 `vector`、`deque`、`string`）**

   ```cpp
   v.reserve(1000);  // 一次性分配足够容量，减少重分配次数
   ```
2. **使用不失效或失效范围最小的容器**

   * 如果需要频繁在中间插入/删除并保持迭代器稳定，可选 `list` 或 `map`。
3. **谨慎持有迭代器**

   * 对于必然会重分配的容器，尽量不要在增删前后跨操作使用原迭代器。
4. **使用索引或偏移量**

   * 有时用整型索引代替迭代器保存位置，中间重分配后重新获取迭代器更安全。

---

**总结：**
迭代器失效是由于容器在执行修改操作时，为了保证性能或内部结构正确性，对底层存储或节点关系做了搬迁、重哈希、指针调整等操作。因此，原本指向元素的迭代器就不再可靠。了解各容器的失效规则，并通过合理的预分配和选择容器，能有效避免因迭代器失效引发的难以排查的 bug。



在C++中，`deque`（双端队列）是一种序列容器，它允许在两端快速插入和删除，并且支持随机访问。`deque`通常由多个固定大小的数组（称为块或缓冲区）实现，这些块通过一个中央映射结构（如指针数组）来管理。这种结构使得在两端添加或删除元素时，不需要移动所有元素，而只需要在必要时分配新的块或释放不再使用的块。

### 迭代器的变化
`deque`的迭代器属于随机访问迭代器。由于`deque`的存储是分块的，迭代器在遍历时可能需要跨块移动。例如，当迭代器指向当前块的末尾时，递增操作会使其跳转到下一个块的开始位置；同样，递减操作会使其跳转到前一个块的末尾。

### 迭代器失效
`deque`的迭代器失效规则相对复杂，因为它的存储结构是分块的。以下是常见操作对迭代器的影响：

1. **在两端插入元素（`push_front`、`push_back`）**：
   - 通常不会使任何迭代器失效（除非由于空间不足导致重新分配映射结构，但这种情况很少见，因为映射结构通常预留了空间）。
   - 注意：在重新分配映射结构（即指向块的指针数组）时，所有迭代器、指针和引用都会失效。但这种情况只发生在当前映射结构不足以容纳更多块时，而这种情况在两端插入时很少发生，因为映射结构通常设计为可以动态增长（例如，以类似vector的方式重新分配，但频率较低）。

2. **在两端删除元素（`pop_front`、`pop_back`）**：
   - 指向被删除元素的迭代器、指针和引用会失效。
   - 其他迭代器、指针和引用通常不受影响。

3. **在中间插入或删除元素（`insert`、`erase`）**：
   - 在中间插入或删除元素会导致所有指向插入点/删除点之后元素的迭代器、指针和引用失效。因为`deque`在中间插入或删除时，为了保持连续性，可能需要移动元素（类似于vector，但移动的元素数量通常较少，只限于插入点所在块及其相邻块的部分元素）。
   - 具体来说，插入操作可能导致重新分配块或者移动元素，从而使得所有迭代器失效（包括指针和引用）。但是，标准规定：
     - 在`deque`中间插入元素通常会导致所有迭代器失效。不过，根据实现，有时可能只使部分迭代器失效（例如，插入点之后的迭代器失效）。但为了可移植性，应假设所有迭代器失效。
     - 删除操作通常使指向被删除元素及其之后元素的迭代器失效。但是，如果删除发生在某个块的中间，那么该块中删除点之后的元素会向前移动，因此这些元素的迭代器会失效；而其他块的迭代器可能不受影响。然而，标准规定，`erase`操作会使所有指向被删除元素的迭代器失效，并且也会使所有指向被删除元素之后元素的迭代器失效（包括尾后迭代器）。因此，删除操作后，不能依赖之前的迭代器（除了被删除元素之前的迭代器可能仍然有效）。

4. **`swap`操作**：
   - 交换两个`deque`的内容。交换后，迭代器、指针和引用会交换到另一个容器中，并保持有效（但指向的元素已经属于另一个容器了）。

5. **`clear`操作**：
   - 清空容器，使所有迭代器失效。

6. **重新分配（例如，`resize`导致容量变化）**：
   - 如果`resize`导致需要重新分配映射结构（即指向块的指针数组），那么所有迭代器、指针和引用都会失效。

### 总结
- **在两端插入或删除**：通常不会使迭代器失效（除了被删除元素的迭代器），除非导致重新分配映射结构（这种情况较少）。
- **在中间插入或删除**：通常会使所有迭代器失效，或者至少使插入点/删除点之后的迭代器失效。具体来说，插入操作可能导致所有迭代器失效；删除操作会使被删除元素及其之后元素的迭代器失效。
- **其他操作**：如`swap`、`clear`等，按照上述规则。

由于不同标准库实现（如libstdc++、libc++）可能有差异，为了可移植性，建议在修改`deque`后，不要继续使用可能失效的迭代器。如果需要，可以重新获取迭代器（如通过`begin()`、`end()`）。

### 示例
```cpp
#include <deque>
#include <iostream>

int main() {
    std::deque<int> d = {1, 2, 3, 4, 5};
    auto it = d.begin() + 2; // 指向3

    d.push_front(0); // 在头部插入，it可能仍然有效（指向3），但不要依赖
    std::cout << *it << std::endl; // 可能输出3，也可能失效（如果重新分配映射结构）

    d.insert(d.begin() + 2, 10); // 在位置2（即原3的位置）插入10，原3后移
    // 此时，it（指向原3）失效，因为插入点之后的元素都移动了
    // 重新获取迭代器
    it = d.begin() + 3;
    std::cout << *it << std::endl; // 输出3

    d.erase(d.begin() + 1); // 删除位置1的元素（即原1）
    // 删除点之后的迭代器（包括it）失效
    // 因此，这里使用it是危险的
    it = d.begin() + 2; // 重新获取
    std::cout << *it << std::endl; // 输出10
}
```


在C++中，`std::deque`（双端队列）的迭代器失效规则与其底层实现（分块连续存储）密切相关。以下是详细分析：

---

### **迭代器的变化机制**
`std::deque` 通常由多个固定大小的块（缓冲区）组成，通过一个中央映射表（指针数组）管理这些块：
1. **随机访问**：迭代器支持 `it + n` 等操作，但需计算目标块的位置。
2. **跨块移动**：当迭代器移动到当前块的边界时，会自动跳转到相邻块的起始或末尾。

---

### **迭代器失效规则**
#### **1. 安全的操作（不失效）**
- **两端插入/删除**：`push_front()`, `push_back()`, `pop_front()`, `pop_back()`
  - **原因**：操作仅在首尾块进行，不影响中间块。
  - **例外**：若操作导致**重新分配中央映射表**（如块指针数组扩容），则**所有迭代器失效**（罕见情况）。

#### **2. 失效的操作**
- **中间插入/删除**：`insert()`, `erase()`, `emplace()`
  - **失效范围**：所有指向**被修改位置之后元素**的迭代器（包括 `end()`）。
  - **原因**：为保持连续性，元素需在块内或跨块移动。
  - **示例**：
    ```cpp
    std::deque<int> d = {1, 2, 3, 4};
    auto it = d.begin() + 2;  // 指向3
    d.insert(it, 10);         // 在3前插入10
    // it 失效！不可再使用
    ```

- **清空容器**：`clear()`
  - **所有迭代器失效**（等同于 `erase(begin(), end())`）。

- **调整大小**：`resize(n)`
  - 若 `n > size()` 且导致新增块，则**所有迭代器失效**（需重新分配中央映射表）。
  - 若 `n < size()`，则**被删除元素之后的迭代器失效**。

- **交换**：`swap()`
  - **迭代器指向的元素不变**，但关联的容器交换（原迭代器仍指向相同值，但属于新容器）。

---

### **失效的迭代器类型**
- **显式失效**：指向被修改位置之后元素的迭代器（包括指针和引用）。
- **隐式失效**：所有**尾后迭代器**（`end()`）在修改后失效，需重新获取。

---

### **总结**
| **操作**               | **失效范围**                     | **原因**                     |
|------------------------|----------------------------------|------------------------------|
| `push_front()/back()`  | 无（除非重分配中央表）           | 仅影响首尾块                 |
| `pop_front()/back()`   | 被删除元素的迭代器               | 元素被销毁                   |
| `insert()/erase()`     | 被修改位置之后的所有迭代器       | 元素移动破坏连续性           |
| `resize()`（扩容）     | 所有迭代器（若需重分配中央表）   | 中央映射表扩容               |
| `clear()`              | 所有迭代器                       | 容器清空                     |
| `swap()`               | 无（迭代器关联到新容器）         | 容器内部指针交换             |

---

### **最佳实践**
1. **避免保存旧迭代器**：在修改 `deque` 后，尽量重新获取迭代器（如 `begin()`、`end()`）。
2. **谨慎中间操作**：频繁在中间插入/删除时，考虑使用 `std::list`（链表迭代器更稳定）。
3. **引用失效**：迭代器失效时，对应的**元素引用也可能失效**（尤其是被删除的元素）。

> 💡 **关键点**：`deque` 的两端操作比中间操作更安全，优先使用 `push/pop_front/back`。