# C++智能指针全面解析与最佳实践

## 一、智能指针概述

智能指针是C++中用于管理动态分配内存的类模板，它们通过RAII（Resource Acquisition Is Initialization）机制自动管理对象的生命周期，有效避免了内存泄漏和悬空指针等问题。

### 1.1 智能指针类型
C++11提供了四种智能指针：
- `std::unique_ptr`：独占所有权的智能指针
- `std::shared_ptr`：共享所有权的智能指针
- `std::weak_ptr`：弱引用智能指针
- `std::auto_ptr`（已废弃）：C++98中的智能指针，现已被`unique_ptr`取代

### 1.2 为什么需要智能指针
- 自动内存管理：防止内存泄漏
- 异常安全：在异常发生时保证资源释放
- 所有权明确：清晰地表达资源所有权关系
- 线程安全：`shared_ptr`提供线程安全的引用计数

## 二、std::unique_ptr详解

### 2.1 基本特性
`std::unique_ptr`实现了独占式拥有概念，同一时间只能有一个`unique_ptr`指向特定对象。

**关键特点**：
- 不可拷贝构造和拷贝赋值
- 支持移动构造和移动赋值
- 默认使用`delete`释放资源
- 可自定义删除器

### 2.2 基本用法示例

```cpp
#include <memory>
#include <iostream>

class Widget {
public:
    Widget() { std::cout << "Widget created\n"; }
    ~Widget() { std::cout << "Widget destroyed\n"; }
    void show() { std::cout << "Widget show\n"; }
};

int main() {
    // 创建unique_ptr
    std::unique_ptr<Widget> up1(new Widget());
    
    // 使用指针
    up1->show();
    
    // 转移所有权
    std::unique_ptr<Widget> up2 = std::move(up1);
    
    if (!up1) {
        std::cout << "up1 is now empty\n";
    }
    
    // up2离开作用域，自动释放Widget
    return 0;
}
```

### 2.3 自定义删除器

```cpp
auto fileDeleter = [](FILE* file) {
    std::cout << "Closing file\n";
    fclose(file);
};

int main() {
    // 使用自定义删除器打开文件
    std::unique_ptr<FILE, decltype(fileDeleter)> filePtr(fopen("test.txt", "r"), fileDeleter);
    
    if (filePtr) {
        char buffer[100];
        fgets(buffer, 100, filePtr.get());
        std::cout << "Read: " << buffer;
    }
    
    // 文件会在unique_ptr析构时自动关闭
    return 0;
}
```

## 三、std::shared_ptr详解

### 3.1 基本特性
`std::shared_ptr`通过引用计数实现共享所有权，当最后一个`shared_ptr`离开作用域时才会释放资源。

**关键特点**：
- 多个`shared_ptr`可以指向同一对象
- 引用计数自动管理
- 线程安全的引用计数操作（但对象访问仍需额外同步）
- 支持自定义删除器

### 3.2 基本用法示例

```cpp
#include <memory>
#include <iostream>

class Resource {
public:
    Resource() { std::cout << "Resource acquired\n"; }
    ~Resource() { std::cout << "Resource released\n"; }
};

int main() {
    // 创建shared_ptr
    std::shared_ptr<Resource> sp1 = std::make_shared<Resource>();
    
    {
        // 拷贝构造增加引用计数
        std::shared_ptr<Resource> sp2 = sp1;
        std::cout << "Use count inside block: " << sp2.use_count() << "\n";
    }
    
    std::cout << "Use count outside block: " << sp1.use_count() << "\n";
    
    // sp1离开作用域，资源被释放
    return 0;
}
```

### 3.3 控制块机制

`shared_ptr`使用控制块来管理引用计数等信息。控制块在以下情况创建：
1. 通过`std::make_shared`创建
2. 从独占指针(`unique_ptr`或`auto_ptr`)构造
3. 从原始指针构造

**重要规则**：不要用同一个原始指针初始化多个`shared_ptr`，这会导致多个控制块和多次释放。

```cpp
// 错误示例 - 不要这样做！
int* rawPtr = new int(42);
std::shared_ptr<int> sp1(rawPtr);
std::shared_ptr<int> sp2(rawPtr);  // 未定义行为！
```

### 3.4 正确创建shared_ptr的方法

1. **使用make_shared（推荐）**
   ```cpp
   auto sp = std::make_shared<Widget>();
   ```

2. **直接传递new表达式**
   ```cpp
   std::shared_ptr<Widget> sp(new Widget);
   ```

3. **从unique_ptr转移**
   ```cpp
   std::unique_ptr<Widget> up(new Widget);
   std::shared_ptr<Widget> sp = std::move(up);
   ```

## 四、std::weak_ptr详解

### 4.1 基本特性
`std::weak_ptr`是`shared_ptr`的伴随类，它不增加引用计数，用于解决循环引用问题。

**关键特点**：
- 不拥有对象所有权
- 不会阻止对象被释放
- 必须转换为`shared_ptr`才能访问对象

### 4.2 基本用法示例

```cpp
#include <memory>
#include <iostream>

class Child;
class Parent {
public:
    std::shared_ptr<Child> child;
    ~Parent() { std::cout << "Parent destroyed\n"; }
};

class Child {
public:
    std::weak_ptr<Parent> parent;  // 使用weak_ptr避免循环引用
    ~Child() { std::cout << "Child destroyed\n"; }
};

int main() {
    auto parent = std::make_shared<Parent>();
    auto child = std::make_shared<Child>();
    
    parent->child = child;
    child->parent = parent;
    
    // 对象会被正确释放，没有内存泄漏
    return 0;
}
```

### 4.3 weak_ptr的使用场景

1. **打破循环引用**
2. **缓存系统**
3. **观察者模式**

```cpp
// 使用weak_ptr访问对象
void useWeakPtr(std::weak_ptr<Widget> weakWidget) {
    if (auto sharedWidget = weakWidget.lock()) {
        // 对象仍然存在，可以使用
        sharedWidget->doSomething();
    } else {
        // 对象已被释放
        std::cout << "Object no longer exists\n";
    }
}
```

## 五、enable_shared_from_this

### 5.1 用途
`std::enable_shared_from_this`允许对象安全地生成自身的`shared_ptr`，而不创建新的控制块。

### 5.2 使用示例

```cpp
#include <memory>
#include <iostream>

class TT : public std::enable_shared_from_this<TT> {
public:
    TT(int v) : v_(v) {}
    
    std::shared_ptr<TT> getShared() {
        return shared_from_this();
    }
    
    void show() { std::cout << "Value: " << v_ << "\n"; }
    
private:
    int v_;
};

int main() {
    auto t1 = std::make_shared<TT>(10);
    auto t2 = t1->getShared();
    
    std::cout << "Use count: " << t1.use_count() << "\n";  // 输出2
    
    t2->show();
    
    return 0;
}
```

**重要注意事项**：
- 必须在对象已被`shared_ptr`管理时才能调用`shared_from_this()`
- 不能在构造函数中调用`shared_from_this()`

## 六、智能指针最佳实践

1. **优先使用make_shared和make_unique**
   - 更高效（单次内存分配）
   - 更安全（避免裸new）
   
   ```cpp
   auto sp = std::make_shared<Widget>(args...);
   auto up = std::make_unique<Widget>(args...);
   ```

2. **避免混用智能指针和裸指针**
   - 不要用裸指针初始化多个智能指针
   - 不要将智能指针管理的对象地址暴露出去

3. **明确所有权语义**
   - 使用`unique_ptr`表达独占所有权
   - 使用`shared_ptr`表达共享所有权
   - 使用`weak_ptr`表达弱引用

4. **注意线程安全性**
   - `shared_ptr`的引用计数操作是线程安全的
   - 但指向的对象访问需要额外同步

5. **处理循环引用**
   - 使用`weak_ptr`打破`shared_ptr`的循环引用

## 七、性能考虑

1. `make_shared` vs 直接构造：
   - `make_shared`通常更高效（单次分配）
   - 但会延长对象生命周期（控制块和对象一起分配）

2. `shared_ptr`开销：
   - 引用计数需要原子操作
   - 控制块需要额外内存
   - 不适合高频创建/销毁的场景

3. 测量和分析：
   - 在性能关键路径上测量智能指针的影响
   - 必要时考虑其他内存管理策略

## 八、常见问题与解决方案

### 8.1 循环引用问题

**问题**：
```cpp
class A {
    std::shared_ptr<B> b_ptr;
};
class B {
    std::shared_ptr<A> a_ptr;
};

auto a = std::make_shared<A>();
auto b = std::make_shared<B>();
a->b_ptr = b;
b->a_ptr = a;  // 循环引用，内存泄漏
```

**解决方案**：使用`weak_ptr`打破循环

```cpp
class B {
    std::weak_ptr<A> a_ptr;  // 使用weak_ptr
};
```

### 8.2 多线程安全问题

**问题**：虽然引用计数是线程安全的，但对象访问需要同步

**解决方案**：
```cpp
std::shared_ptr<Data> globalData;

void threadFunc() {
    std::shared_ptr<Data> localCopy;
    {
        std::lock_guard<std::mutex> lock(mutex);
        localCopy = globalData;  // 引用计数增加是原子的
    }
    // 使用localCopy，不需要锁
}
```

### 8.3 自定义删除器的使用

**场景**：管理非内存资源（如文件、套接字等）

**示例**：
```cpp
auto dbDeleter = [](Database* db) {
    db->close();
    delete db;
};

std::shared_ptr<Database> dbPtr(new Database(), dbDeleter);
```

## 九、总结

C++智能指针是现代C++编程中不可或缺的工具，它们提供了安全、便捷的内存管理方式。理解并正确使用各种智能指针，可以显著提高代码的健壮性和可维护性。记住以下要点：

1. 优先使用`unique_ptr`表达独占所有权
2. 谨慎使用`shared_ptr`，避免不必要的共享
3. 使用`weak_ptr`解决循环引用问题
4. 优先使用`make_shared`和`make_unique`
5. 避免混用智能指针和裸指针