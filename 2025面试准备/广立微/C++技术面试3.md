
# C++ 技术面试准备指南
## 15. 说说你知道的设计模式。
### **1. 核心知识点解析**
设计模式是解决软件设计问题的经典方案，主要分为三类：

- **创建型模式**：关注对象的创建机制
  - 单例模式（Singleton）
  - 工厂模式（Factory）
  - 建造者模式（Builder）
  - 原型模式（Prototype）

- **结构型模式**：关注类和对象的组合
  - 适配器模式（Adapter）
  - 装饰器模式（Decorator）
  - 代理模式（Proxy）
  - 外观模式（Facade）

- **行为型模式**：关注对象间职责分配
  - 观察者模式（Observer）
  - 策略模式（Strategy）
  - 命令模式（Command）
  - 状态模式（State）

### **2. 标准化面试回答模板**
> 我了解常见的23种设计模式，主要分为创建型、结构型和行为型三类。在实际开发中，我经常使用单例模式确保全局唯一实例，工厂模式解耦对象创建过程，观察者模式实现事件通知机制。这些模式提高了代码的可维护性和可扩展性。

### **3. 代码示例与最佳实践**
```cpp
// 工厂模式示例
class Product {
public:
    virtual ~Product() = default;
    virtual void use() = 0;
};

class ConcreteProductA : public Product {
public:
    void use() override { std::cout << "Using Product A\n"; }
};

class Factory {
public:
    static std::unique_ptr<Product> createProduct(const std::string& type) {
        if (type == "A") {
            return std::make_unique<ConcreteProductA>();
        }
        return nullptr;
    }
};
```

### **4. 面试官视角分析**
- **考察点**：设计思维和代码架构能力
- **优秀回答**：能结合实际项目说明模式的应用场景
- **深入追问**：如何选择合适的设计模式？现代C++如何简化模式实现？

### **5. 学习建议与知识扩展**
- 学习《设计模式：可复用面向对象软件的基础》
- 了解现代C++中的Policy-Based Design
- 掌握模板元编程在模式实现中的应用

---

## 16. 单例模式怎么使用，会有什么问题，怎么解决？

### **1. 核心知识点解析**
单例模式确保一个类只有一个实例，并提供全局访问点。

**常见问题**：
- 线程安全问题
- 构造顺序问题（Static Initialization Order Fiasco）
- 内存泄漏问题
- 测试困难

**解决方案**：
- 使用局部静态变量（C++11保证线程安全）
- Meyer's Singleton模式
- 智能指针管理生命周期

### **2. 标准化面试回答模板**
> 单例模式通过私有构造函数和静态成员函数实现全局唯一实例。传统实现存在线程安全和构造顺序问题。现代C++推荐使用Meyer's Singleton，即在静态函数中返回局部静态变量，C++11保证其线程安全且延迟初始化。对于更复杂场景，可以使用智能指针和工厂模式结合。

### **3. 代码示例与最佳实践**
```cpp
// Meyer's Singleton (推荐)
class Singleton {
public:
    static Singleton& getInstance() {
        static Singleton instance; // C++11线程安全
        return instance;
    }
    
    void doSomething() {
        std::cout << "Singleton doing something\n";
    }

private:
    Singleton() = default;
    ~Singleton() = default;
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;
};

// 使用
Singleton::getInstance().doSomething();

// 线程安全的智能指针版本
class ThreadSafeSingleton {
public:
    static std::shared_ptr<ThreadSafeSingleton> getInstance() {
        static std::shared_ptr<ThreadSafeSingleton> instance{
            new ThreadSafeSingleton{}
        };
        return instance;
    }

private:
    ThreadSafeSingleton() = default;
};
```

### **4. 面试官视角分析**
- **考察点**：对线程安全、内存管理和设计模式的综合理解
- **优秀回答**：能指出传统实现的问题并提供现代解决方案
- **深入追问**：单例模式的缺点？如何进行单元测试？

### **5. 学习建议与知识扩展**
- 了解依赖注入替代单例模式
- 学习现代C++中的线程安全保证
- 掌握单例模式在多线程环境下的测试方法

---

## 17. 类属性的初始化有哪几种方法，它们的初始化顺序是怎样的？

### **1. 核心知识点解析**
C++中类成员变量的初始化方式：

**初始化方式**：
1. **初始化列表**：在构造函数冒号后初始化
2. **默认成员初始化器**：C++11在类内直接初始化
3. **构造函数体内赋值**：在构造函数大括号内赋值
4. **聚合初始化**：对于聚合类型使用大括号初始化

**初始化顺序**：
1. 基类按声明顺序初始化
2. 成员变量按声明顺序初始化（非初始化列表顺序）
3. 构造函数体内执行

### **2. 标准化面试回答模板**
> C++提供了多种成员变量初始化方式：初始化列表、默认成员初始化器、构造函数体内赋值和聚合初始化。初始化顺序严格按照成员变量在类中声明的顺序进行，而非初始化列表中的顺序。对于性能敏感的场景，推荐使用初始化列表和默认成员初始化器，避免不必要的构造和赋值操作。

### **3. 代码示例与最佳实践**
```cpp
class MyClass {
private:
    int a;                    // 1st
    std::string b = "default"; // 2nd (默认成员初始化)
    double c;                 // 3rd

public:
    // 推荐：使用初始化列表
    MyClass(int val) : c(3.14), a(val), b("initialized") {
        // 构造函数体内执行最后
    }
    
    // C++11聚合初始化
    struct Point {
        int x = 0;
        int y = 0;
    };
    
    Point p{10, 20}; // 聚合初始化
};

// 基类和派生类初始化顺序
class Base {
public:
    Base() { std::cout << "Base\n"; }
};

class Derived : public Base {
private:
    int member;
public:
    Derived() : member(42) { std::cout << "Derived\n"; }
    // 实际顺序：Base -> member -> Derived构造函数体
};
```

### **4. 面试官视角分析**
- **考察点**：对C++对象模型和构造过程的深入理解
- **优秀回答**：能准确说明初始化顺序和性能影响
- **深入追问**：虚继承情况下的初始化顺序？移动构造函数中的初始化？

### **5. 学习建议与知识扩展**
- 深入学习C++对象模型（推荐《深度探索C++对象模型》）
- 掌握初始化列表与构造函数体内赋值的性能差异
- 了解C++17结构化绑定和类模板参数推导

---

## 18. static关键字的意义？

### **1. 核心知识点解析**
`static`关键字在C++中有多种含义，根据使用场景不同：

**在类外部**：
- **静态变量**：具有内部链接性，只在当前文件可见
- **静态函数**：具有内部链接性，只在当前文件可见

**在类内部**：
- **静态成员变量**：属于类而非实例，所有对象共享
- **静态成员函数**：不依赖于类实例，不能访问非静态成员

**在函数内部**：
- **局部静态变量**：只初始化一次，生命周期贯穿程序运行期

### **2. 标准化面试回答模板**
> static关键字在C++中有多重含义。在文件作用域中，static使变量或函数具有内部链接性，仅在当前文件可见。在类中，static成员变量和函数属于类本身而非实例，静态成员变量需在类外定义。在函数内，static局部变量只初始化一次且生命周期持续到程序结束。现代C++推荐使用匿名命名空间替代文件作用域的static。

### **3. 代码示例与最佳实践**
```cpp
// 1. 文件作用域static（推荐使用匿名命名空间）
static int file_local_var = 0;        // 仅当前文件可见
static void file_local_func() {}      // 仅当前文件可见

// 推荐替代方案
namespace {
    int file_local_var = 0;
    void file_local_func() {}
}

// 2. 类内static成员
class Counter {
private:
    static int count;                 // 声明
    mutable int instance_count = 0;   // C++11默认成员初始化

public:
    Counter() { 
        ++count; 
        ++instance_count;
    }
    
    static int getCount() {           // 静态成员函数
        return count;
    }
    
    int getInstanceCount() const {    // 普通成员函数
        return instance_count;
    }
};

int Counter::count = 0;               // 定义

// 3. 函数内static变量
int generateID() {
    static int id = 0;                // 只初始化一次
    return ++id;
}

// 4. C++17 inline变量（解决静态成员定义问题）
class Logger {
public:
    inline static std::string name = "DefaultLogger"; // C++17
};
```

### **4. 面试官视角分析**
- **考察点**：对C++存储类说明符和链接性的理解
- **优秀回答**：能区分不同场景下的static含义和现代替代方案
- **深入追问**：线程安全性？静态成员的内存布局？extern "C"中的static？

### **5. 学习建议与知识扩展**
- 学习C++中的链接性概念
- 掌握C++17 inline变量的使用
- 了解线程安全的局部静态变量初始化（C++11保证）
- 理解静态成员在继承中的行为
