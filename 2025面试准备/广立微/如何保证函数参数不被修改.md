
# 如何保证函数参数不被修改
## 1. 核心知识点解析
### 本质与原理
在C++中，保证函数参数不被修改的核心机制是**const正确性**（const correctness）。通过在函数声明和定义中使用`const`关键字，可以向编译器和调用者明确表达参数的不可变性。

### 关键概念区分

#### 值传递 vs 引用传递 vs 指针传递
- **值传递**：默认情况下，函数参数是按值传递的，函数内部对参数的修改不会影响原始变量
- **const引用传递**：`const T&`既能避免拷贝开销，又能保证参数不被修改
- **const指针传递**：`const T*`和`T* const`有不同的含义，需要仔细区分

#### const的语义
- `const T& param`：参数是只读引用
- `const T* param`：参数是指向常量的指针
- `T* const param`：参数是常量指针（指针本身不可变）

### 实际应用场景
- 接口设计：明确表达函数不会修改输入参数
- 性能优化：避免不必要的拷贝同时保证安全性
- API文档化：通过类型系统表达设计意图

## 2. 标准化面试回答模板

### 基础回答框架
```cpp
// 1. 值传递 - 适用于小对象
void processValue(int value) {
    // value是副本，修改不影响原值
}

// 2. const引用传递 - 推荐方式，适用于大对象
void processObject(const std::string& str) {
    // str不能被修改，避免拷贝开销
    std::cout << str.length() << std::endl;  // 只读操作
}

// 3. const指针传递
void processArray(const int* arr, size_t size) {
    // arr指向的数据不能被修改
    for (size_t i = 0; i < size; ++i) {
        std::cout << arr[i] << " ";
    }
}
```

### 进阶回答要点
1. **优先使用const引用**：对于非基础类型，既保证不被修改又避免拷贝
2. **合理选择传递方式**：
   - 基础类型：值传递
   - 大对象：const引用
   - 可选参数：std::optional<const T&>（C++17）
3. **现代C++实践**：
   - 使用std::string_view（C++17）处理只读字符串
   - 结合移动语义优化性能

## 3. 代码示例与最佳实践

### 推荐实践示例
```cpp
#include <iostream>
#include <string>
#include <vector>
#include <string_view>

class DataProcessor {
public:
    // 基础类型 - 值传递
    static int calculate(int a, int b) {
        return a + b;
    }
    
    // 字符串处理 - const引用 + string_view
    static size_t getStringLength(const std::string& str) {
        return str.length();
    }
    
    // C++17 - string_view用于只读场景
    static bool isEmpty(std::string_view sv) {
        return sv.empty();
    }
    
    // 容器处理 - const引用
    static void printVector(const std::vector<int>& vec) {
        for (const auto& item : vec) {
            std::cout << item << " ";
        }
        std::cout << std::endl;
    }
    
    // 指针参数 - const指针
    static int sumArray(const int* arr, size_t size) {
        int sum = 0;
        for (size_t i = 0; i < size; ++i) {
            sum += arr[i];  // 只读访问
        }
        return sum;
    }
};

// 错误示例 - 应该避免的做法
void badExample(std::string str) {  // 造成不必要的拷贝
    std::cout << str.length() << std::endl;
}

// 正确示例 - 推荐做法
void goodExample(const std::string& str) {  // 避免拷贝，保证不被修改
    std::cout << str.length() << std::endl;
}
```

### 异常安全考虑
```cpp
class SafeProcessor {
public:
    // const成员函数保证不修改对象状态
    size_t processData(const std::vector<int>& data) const {
        // const正确性贯穿整个调用链
        return std::count_if(data.begin(), data.end(), 
                           [](const int& value) { return value > 0; });
    }
};
```

## 4. 面试官视角分析

### 考察能力点
1. **基础语法掌握**：const关键字的正确使用
2. **性能意识**：理解不同传递方式的性能影响
3. **设计思维**：通过类型系统表达设计意图
4. **现代C++知识**：了解C++11/14/17相关特性

### 优秀回答特征
- 能够清晰区分不同传递方式的适用场景
- 展示对const语义的深入理解
- 体现性能优化意识
- 了解现代C++最佳实践

### 可能的深入追问
1. **"const引用和const指针有什么区别？"**
   - 回答要点：语法差异、使用场景、生命周期管理

2. **"为什么基础类型不建议用const引用？"**
   - 回答要点：性能考虑、编译器优化、代码可读性

3. **"C++17的string_view解决了什么问题？"**
   - 回答要点：避免拷贝、统一接口、性能提升

## 5. 学习建议与知识扩展

### 相关知识点延伸
1. **const正确性完整体系**：
   - const成员函数
   - mutable关键字
   - const_cast的使用场景

2. **现代C++参数传递**：
   - 完美转发（std::forward）
   - 移动语义（std::move）
   - 引用折叠规则

3. **性能优化相关**：
   - 拷贝省略（Copy Elision）
   - RVO/NRVO优化
   - 内存对齐考虑

### 常见面试陷阱提醒
⚠️ **陷阱1**：混淆`const T*`和`T* const`
```cpp
const int* ptr1;  // 指向常量的指针
int* const ptr2;  // 常量指针
const int* const ptr3;  // 指向常量的常量指针
```

⚠️ **陷阱2**：忽略const引用的生命周期问题
```cpp
const std::string& getTempString() {
    return std::string("temp");  // 危险！返回临时对象的引用
}
```

⚠️ **陷阱3**：性能误区
```cpp
// 对于基础类型，const引用可能比值传递更慢
void process(int value);        // 推荐
void process(const int& value); // 不推荐用于int等基础类型
```
