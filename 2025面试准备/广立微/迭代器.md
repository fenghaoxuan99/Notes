## 迭代器详解

## 什么是迭代器？

**迭代器**是一种抽象的设计概念，它提供了一种统一的方式来访问容器中的元素，而不需要暴露容器的内部实现细节。可以理解为"智能指针"，让你能够遍历容器中的元素。

```cpp
vector<int> v = {1, 2, 3, 4, 5};
// 使用迭代器遍历
for (auto it = v.begin(); it != v.end(); ++it) {
    cout << *it << " ";  // 解引用访问元素
}
```

## 面试必须掌握的迭代器知识

### 1. 迭代器的五种分类（重要）

| 迭代器类型 | 支持操作 | 典型容器 |
|-----------|---------|---------|
| **输入迭代器** | 只读，单次遍历 | istream_iterator |
| **输出迭代器** | 只写，单次遍历 | ostream_iterator |
| **前向迭代器** | 读写，多次遍历 | forward_list |
| **双向迭代器** | 前后移动 | list, set, map |
| **随机访问迭代器** | 任意跳跃 | vector, deque, array |

```cpp
// 随机访问迭代器支持的额外操作
vector<int> v = {1, 2, 3, 4, 5};
auto it = v.begin();
it += 3;        // 跳跃访问
it -= 2;        // 向后跳跃
int diff = it2 - it1;  // 计算距离
if (it1 < it2)  // 比较位置
```

### 2. 迭代器的基本操作

```cpp
container::iterator it;
*it          // 解引用，访问元素
it->member   // 访问成员
++it         // 前置递增
it++         // 后置递增
--it         // 前置递减（双向迭代器）
it--         // 后置递减（双向迭代器）
it1 == it2   // 比较
it1 != it2   // 比较
```

### 3. 容器的迭代器类型

```cpp
vector<int> v;           // iterator是随机访问迭代器
list<int> l;             // iterator是双向迭代器
set<int> s;              // iterator是双向迭代器
unordered_map<int,int> um; // iterator是前向迭代器
```

### 4. 常用迭代器类型

```cpp
vector<int> v = {1, 2, 3, 4, 5};

// 普通迭代器
vector<int>::iterator it1 = v.begin();

// 常量迭代器（只读）
vector<int>::const_iterator it2 = v.cbegin();

// 反向迭代器
vector<int>::reverse_iterator rit = v.rbegin();

// 常量反向迭代器
vector<int>::const_reverse_iterator crit = v.crbegin();
```

### 5. 算法与迭代器的配合

```cpp
vector<int> v = {3, 1, 4, 1, 5};
// 算法需要迭代器作为参数
sort(v.begin(), v.end());           // 需要随机访问迭代器
auto it = find(v.begin(), v.end(), 4); // 前向迭代器即可
reverse(v.begin(), v.end());        // 双向迭代器
```

## 面试高频考点

### 1. 迭代器与指针的关系

```cpp
// vector的iterator通常就是指针
vector<int> v = {1, 2, 3};
int* ptr = &v[0];        // 指针
vector<int>::iterator it = v.begin();  // 迭代器
// 在vector中，it和ptr行为相似

// 但其他容器不是
list<int> l = {1, 2, 3};
// list<int>::iterator不是指针，是复杂的类
```

### 2. const相关迭代器

```cpp
const vector<int> v = {1, 2, 3};
// 只能使用const_iterator
auto it = v.begin();  // 实际是const_iterator
*it = 10;  // 编译错误，不能修改

vector<int> v2 = {1, 2, 3};
auto it2 = v2.cbegin();  // 显式获取const_iterator
*it2 = 10;  // 编译错误
```

### 3. 安全使用迭代器

```cpp
// ❌ 错误：使用无效迭代器
vector<int> v = {1, 2, 3};
auto it = v.end();
cout << *it;  // 未定义行为

// ❌ 错误：越界访问
vector<int> v = {1, 2, 3};
auto it = v.begin() + 10;  // 越界

// ✅ 正确做法
if (it != v.end()) {
    cout << *it;
}
```

### 4. 迭代器适配器

```cpp
vector<int> v = {1, 2, 3, 4, 5};

// 反向迭代器
for (auto it = v.rbegin(); it != v.rend(); ++it) {
    cout << *it << " ";  // 输出: 5 4 3 2 1
}

// 插入迭代器
back_insert_iterator<vector<int>> inserter(v);
*inserter = 6;  // 等价于v.push_back(6)

// 流迭代器
istream_iterator<int> in_it(cin);
istream_iterator<int> end_it;
vector<int> nums(in_it, end_it);  // 从输入流读取所有数字
```

## 面试可能的深入问题

### Q: 为什么需要不同类型的迭代器？
A: 为了匹配不同容器的访问特性，提供最优的性能和功能。

### Q: 如何自定义迭代器？
A: 继承std::iterator或实现迭代器的五要素：value_type, difference_type, pointer, reference, iterator_category

### Q: 迭代器的性能差异？
A: 随机访问 > 双向 > 前向 > 输入/输出

## 实用技巧总结

```cpp
// 1. 使用auto简化迭代器声明
for (auto it = container.begin(); it != container.end(); ++it)

// 2. 范围for循环（C++11）
for (const auto& element : container)

// 3. 安全检查
auto it = find(container.begin(), container.end(), value);
if (it != container.end()) {
    // 找到了，可以安全使用it
}

// 4. 使用cbegin/cend获取const迭代器
auto it = container.cbegin();  // 明确表示不修改
```

## 必须记住的关键点

1. **迭代器失效问题**（前面详细讨论过）
2. **不同类型迭代器的功能差异**
3. **const迭代器的使用场景**
4. **算法需要的迭代器类型要求**
5. **安全使用迭代器的原则**
