

## 什么时候必须用完整类型定义？
1. **创建对象实例** - 需要知道对象大小
2. **继承关系** - 基类必须完整定义
3. **成员函数调用** - 需要访问函数体和成员变量
4. **使用sizeof操作符** - 需要知道确切大小
5. **访问成员变量** - 需要成员偏移信息
6. **模板实例化** - 模板参数通常需要完整类型

### 标准化面试回答模板

"在以下情况下必须使用完整类型定义：

1. **对象创建和内存分配**：当需要为对象分配内存时，编译器必须知道对象的确切大小
2. **成员访问**：访问类的成员变量或调用成员函数时需要完整定义
3. **继承关系**：派生类继承基类时，基类必须完整定义
4. **模板特化**：模板参数通常要求完整类型
5. **运算符重载**：使用需要完整类型的操作符时"

### 代码示例与最佳实践

```cpp
// 必须使用完整类型的情况
class CompleteType {
private:
    int data;
    std::string name;
public:
    void method() { /* implementation */ }
    int getData() const { return data; }
};

// 场景1：对象创建 - 必须完整类型
CompleteType obj;  // 需要知道sizeof(CompleteType)
CompleteType* ptr = new CompleteType();  // 同样需要完整类型

// 场景2：成员访问 - 必须完整类型
obj.method();  // 需要函数体信息
int value = obj.getData();  // 需要成员偏移信息

// 场景3：继承 - 基类必须完整
class Derived : public CompleteType {  // 基类必须完整定义
    // ...
};

// 场景4：sizeof操作
size_t size = sizeof(CompleteType);  // 需要确切大小

// 可以使用前向声明的场景
class ForwardDeclared;  // 前向声明

class MyClass {
    ForwardDeclared* ptr;     // 指针 - 可以前向声明
    ForwardDeclared& ref;     // 引用 - 可以前向声明
    
    // ForwardDeclared obj;   // 错误！值类型需要完整定义
    // ForwardDeclared arr[10]; // 错误！数组需要完整定义
    
public:
    void setPtr(ForwardDeclared* p) { ptr = p; }  // 参数类型可前向声明
    // void useObj(ForwardDeclared obj);  // 错误！值传递需要完整定义
};
```

## 前向声明有什么限制？
### 核心知识点解析
**前向声明的核心限制源于编译器需要的信息量**：

1. **不知道对象大小** - 无法进行内存分配
2. **不知道成员布局** - 无法访问成员变量
3. **不知道函数签名** - 无法验证函数调用
4. **不知道继承关系** - 无法进行类型转换

### 标准化面试回答模板

"前向声明的主要限制包括：

1. **无法创建对象实例** - 只能声明指针或引用
2. **无法访问成员** - 不能调用成员函数或访问成员变量
3. **无法确定大小** - 不能使用sizeof操作符
4. **模板参数限制** - 某些模板上下文要求完整类型
5. **函数重载解析** - 可能影响重载决议的准确性"

### 代码示例与最佳实践

```cpp
class ForwardClass;  // 前向声明

class Example {
    ForwardClass* ptr;    // ✓ 正确 - 指针
    ForwardClass& ref;    // ✓ 正确 - 引用
    // ForwardClass obj;  // ✗ 错误 - 需要完整类型定义
    
public:
    // 函数声明可以使用前向声明的类型
    void setForward(ForwardClass* f);           // ✓ 正确
    ForwardClass* getForward() const;           // ✓ 正确
    // ForwardClass getValue();                 // ✓ 语法正确，但实现时需要完整定义
    
    void useForward() {
        // ptr->someMethod();  // ✗ 错误 - 不知道方法是否存在
        // sizeof(ForwardClass); // ✗ 错误 - 不知道大小
        // ForwardClass local;   // ✗ 错误 - 无法分配内存
    }
};

// 在实现文件中包含完整定义
#include "ForwardClass.h"  // 假设这是完整定义

void Example::setForward(ForwardClass* f) {
    ptr = f;
}

void Example::useForward() {
    // 现在可以调用方法了
    if (ptr) {
        ptr->publicMethod();  // ✓ 正确 - 有了完整定义
    }
}
```

## Pimpl惯用法如何解决循环依赖？
### 核心知识点解析
**Pimpl (Pointer to Implementation) 模式的核心思想**：
- 将实现细节隐藏在私有指针后面
- 头文件只包含接口声明
- 实现文件包含所有依赖

**解决循环依赖的原理**：
- 头文件中只声明不定义
- 所有具体类型依赖都在实现文件中
- 打破编译时依赖链

### 标准化面试回答模板

"Pimpl"惯用法通过以下方式解决循环依赖：

1. **接口与实现分离**：头文件只暴露接口，隐藏实现细节
2. **延迟依赖解析**：将循环依赖推迟到实现文件中解决
3. **减少编译依赖**：客户端代码不直接依赖实现细节
4. **提高编译速度**：减少头文件包含，降低编译耦合度

### 代码示例与最佳实践

```cpp
// Widget.h - 接口文件，无循环依赖
#include <memory>

class Widget {
public:
    Widget();
    ~Widget();  // 必须在实现文件中定义
    
    void doSomething();
    void setRelated(RelatedClass* related);
    
private:
    class Impl;  // 前向声明实现类
    std::unique_ptr<Impl> pImpl;  // 指向实现的智能指针
};

// Widget.cpp - 实现文件
#include "Widget.h"
#include "RelatedClass.h"  // 可以安全包含，解决循环依赖

// 实现类定义
class Widget::Impl {
public:
    RelatedClass* relatedPtr;
    int data;
    
    void doSomethingImpl() {
        if (relatedPtr) {
            relatedPtr->callback();  // 可以安全调用
        }
    }
};

// 构造函数实现
Widget::Widget() : pImpl(std::make_unique<Impl>()) {}

// 析构函数必须在实现文件中定义（因为需要Impl的完整定义）
Widget::~Widget() = default;

void Widget::doSomething() {
    pImpl->doSomethingImpl();
}

void Widget::setRelated(RelatedClass* related) {
    pImpl->relatedPtr = related;
}

// RelatedClass.h - 另一个类
#include <memory>

class RelatedClass {
public:
    RelatedClass();
    ~RelatedClass();
    
    void callback();
    void setWidget(Widget* widget);  // 现在可以相互引用！
    
private:
    class Impl;
    std::unique_ptr<Impl> pImpl;
};

// RelatedClass.cpp
#include "RelatedClass.h"
#include "Widget.h"  // 安全包含，无循环依赖

class RelatedClass::Impl {
public:
    Widget* widgetPtr;
    std::string name;
};

RelatedClass::RelatedClass() : pImpl(std::make_unique<Impl>()) {}
RelatedClass::~RelatedClass() = default;

void RelatedClass::callback() {
    // 实现...
}

void RelatedClass::setWidget(Widget* widget) {
    pImpl->widgetPtr = widget;
}
```

### 现代C++ Pimpl最佳实践

```cpp
// 使用C++11/14/17特性的现代Pimpl
#include <memory>
#include <string>

class ModernWidget {
public:
    ModernWidget();
    ~ModernWidget();  // 必需
    
    // 移动语义支持
    ModernWidget(ModernWidget&&) noexcept;
    ModernWidget& operator=(ModernWidget&&) noexcept;
    
    // 禁用拷贝（或实现深拷贝）
    ModernWidget(const ModernWidget&) = delete;
    ModernWidget& operator=(const ModernWidget&) = delete;
    
    void setName(const std::string& name);
    std::string getName() const;
    
private:
    struct Impl;
    std::unique_ptr<Impl> pImpl;
};

// 实现文件中
struct ModernWidget::Impl {
    std::string name;
    int value = 0;
    // 其他实现细节...
};

ModernWidget::ModernWidget() 
    : pImpl(std::make_unique<Impl>()) {}

ModernWidget::~ModernWidget() = default;

ModernWidget::ModernWidget(ModernWidget&&) noexcept = default;
ModernWidget& ModernWidget::operator=(ModernWidget&&) noexcept = default;

void ModernWidget::setName(const std::string& name) {
    pImpl->name = name;
}

std::string ModernWidget::getName() const {
    return pImpl->name;
}
```

## 面试官视角分析

**这些追问想考察什么**：
- 对C++类型系统深入理解
- 编译时vs运行时概念掌握
- 实际工程问题解决能力
- 现代C++最佳实践应用

**优秀回答应该包含**：
- 理论基础扎实
- 实际代码示例
- 最佳实践指导
- 设计原则说明

**进一步可能的追问**：
- "Pimpl的性能影响如何？"
- "如何处理Pimpl中的异常安全？"
- "智能指针在Pimpl中的选择策略？"