
## 核心答案
**map**: 插入操作后**原有迭代器不会失效**
**unordered_map**: 插入操作后**原有迭代器可能会失效**
## 详细解释

### map（红黑树实现）
```cpp
std::map<int, string> m;
m[1] = "one";
m[2] = "two";
auto it = m.find(1);  // 获取迭代器
m[3] = "three";       // 插入新元素
// it 仍然有效，可以安全使用
cout << it->second;   // 正常输出 "one"
```

**原因**: map底层是平衡二叉树（红黑树），插入新节点不会影响已有节点的内存位置。

### unordered_map（哈希表实现）
```cpp
std::unordered_map<int, string> um;
um[1] = "one";
um[2] = "two";
auto it = um.find(1);  // 获取迭代器
um[3] = "three";       // 插入新元素
// it 可能已经失效！
// cout << it->second;  // 可能导致未定义行为
```

**原因**: 
- 当插入导致rehash（重新分配桶）时，所有元素可能被重新分布
- 内存地址改变，原有迭代器指向无效位置

## 面试要点总结

### 1. 底层数据结构差异
- **map**: 平衡二叉树，节点独立分配
- **unordered_map**: 哈希表，连续内存块管理

### 2. 复杂度对比
| 操作 | map | unordered_map |
|------|-----|---------------|
| 插入 | O(log n) | 平均O(1)，最坏O(n) |
| 迭代器稳定性 | 稳定 | 不稳定 |

### 3. 面试官可能的追问
**Q: 什么情况下unordered_map迭代器一定失效？**
A: 发生rehash时（load factor超过阈值）

**Q: 如何安全使用unordered_map迭代器？**
A: 插入后重新获取迭代器，或使用下标/at()访问

### 4. 实际应用建议
```cpp
// 好的做法
auto it = um.find(key);
if (it != um.end()) {
    // 使用it->second
}

// 避免在可能rehash的操作后继续使用旧迭代器
um[new_key] = value;  // 可能导致rehash
// 不要再使用之前的it
```

## 记忆技巧
**map**: 有序 -> 稳定 -> 迭代器不失效
**unordered_map**: 无序 -> 动态 -> 迭代器可能失效



## 迭代器失效详解

### 什么是迭代器失效？

**迭代器失效**是指迭代器不再指向有效的元素，继续使用会导致**未定义行为**（程序崩溃、数据错误等）。

```cpp
vector<int> v = {1, 2, 3, 4, 5};
auto it = v.begin();  // it指向第一个元素
v.push_back(6);       // 可能导致内存重新分配
// 此时it可能已经失效，使用it是危险的
```

## 各容器迭代器失效情况总结

### 1. vector/deque
**插入/删除操作**：
- **尾部插入**: 仅当capacity不足导致重新分配时，**所有迭代器失效**
- **中间插入/删除**: **所有迭代器失效**
- **头部插入/删除**: **所有迭代器失效**

```cpp
vector<int> v = {1, 2, 3};
auto it = v.begin();
v.push_back(4);     // 如果重新分配内存，则it失效
v.insert(v.begin() + 1, 10);  // it失效
```

### 2. list/forward_list
**插入操作**：
- **不影响其他迭代器**，只有指向被删除元素的迭代器失效

```cpp
list<int> l = {1, 2, 3};
auto it = l.begin();  // 指向1
l.insert(l.begin(), 0);  // 在前面插入0
// it仍然有效，仍指向1
```

### 3. map/multimap
**插入/删除操作**：
- **所有迭代器保持有效**
- **所有引用保持有效**

```cpp
map<int, string> m = {{1, "one"}, {2, "two"}};
auto it = m.find(1);
m[3] = "three";  // 插入新元素
m.erase(2);      // 删除元素2
// it仍然有效
```

### 4. unordered_map/unordered_set
**插入操作**：
- **可能导致rehash，所有迭代器失效**
- **所有指针和引用保持有效**（注意区别）

**删除操作**：
- **仅指向被删除元素的迭代器失效**

```cpp
unordered_map<int, string> um = {{1, "one"}, {2, "two"}};
auto it = um.find(1);
um[3] = "three";  // 可能rehash，it可能失效
// 安全做法：重新获取迭代器
it = um.find(1);
```

## 面试高频考点

### 1. 容器分类记忆法

**节点式容器**（稳定）：
- `list`, `forward_list`, `set`, `map`, `multiset`, `multimap`
- **插入/删除不影响其他元素的迭代器**

**连续内存容器**（不稳定）：
- `vector`, `deque`, `string`
- **可能因内存重新分配导致所有迭代器失效**

**哈希容器**（部分稳定）：
- `unordered_map`, `unordered_set`等
- **插入可能导致rehash，所有迭代器失效**
- **删除只影响被删除元素的迭代器**

### 2. 实际编程建议

```cpp
// ❌ 危险做法
vector<int> v = {1, 2, 3, 4, 5};
for (auto it = v.begin(); it != v.end(); ++it) {
    if (*it == 3) {
        v.push_back(10);  // 可能导致it失效
        cout << *it;      // 危险！
    }
}

// ✅ 安全做法
vector<int> v = {1, 2, 3, 4, 5};
for (size_t i = 0; i < v.size(); ++i) {
    if (v[i] == 3) {
        v.push_back(10);  // 使用下标访问
        break;
    }
}
```

### 3. 面试官可能的深入问题

**Q: 为什么vector插入会导致所有迭代器失效？**
A: vector使用连续内存，容量不足时会重新分配更大的内存块并复制元素，原地址失效。

**Q: unordered_map为什么只有指针引用有效，迭代器却失效？**
A: rehash后元素在新的桶中位置改变，但元素本身在内存中的地址不变。

**Q: 如何检测迭代器失效？**
A: 调试模式下使用迭代器调试器，或使用内存检测工具如Valgrind。

## 总结表格

| 容器 | 插入失效情况 | 删除失效情况 |
|------|-------------|-------------|
| vector/deque | 内存重分配时全部失效 | 全部失效 |
| list | 无 | 仅被删除元素 |
| map/set | 无 | 仅被删除元素 |
| unordered_map | rehash时全部失效 | 仅被删除元素 |