# 冒泡排序详解

## 1. 基本思想

冒泡排序是一种简单的交换排序算法，其基本思想是通过**相邻元素之间的比较和交换**，使得较大的元素逐渐"浮"到数组的末端（或较小的元素"沉"到前端），就像气泡在水中上浮一样，因此得名"冒泡排序"。

算法通过**多轮遍历**数组实现排序，每一轮都会将当前未排序部分的最大元素移动到正确位置。经过n-1轮后，整个数组就完成了排序。

## 2. 代码实现

```cpp
#include <iostream>
#include <vector>
#include <algorithm> // 用于std::swap

void bubbleSort(std::vector<int>& arr) {
    int n = arr.size();
    for (int i = 0; i < n - 1; ++i) { // 外层循环控制轮数
        bool swapped = false; // 优化：记录本轮是否发生交换
        for (int j = 0; j < n - 1 - i; ++j) { // 内层循环控制每轮比较次数
            if (arr[j] > arr[j + 1]) { // 如果前一个元素大于后一个元素
                std::swap(arr[j], arr[j + 1]); // 交换两个元素
                swapped = true; // 标记发生了交换
            }
        }
        if (!swapped) break; // 如果本轮没有发生交换，说明数组已经有序，提前结束
    }
}


int main() {
    std::vector<int> arr = {64, 34, 25, 12, 22, 11, 90};
    
    std::cout << "排序前: ";
    for (int num : arr) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
    
    bubbleSort(arr);
    
    std::cout << "排序后: ";
    for (int num : arr) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
    
    return 0;
}
```

## 3. 时间复杂度分析

- **最好情况**：O(n) - 当输入数组已经是有序的，且使用优化版本（检测到无交换时提前退出）
- **最坏情况**：O(n²) - 当输入数组是逆序的，需要进行n(n-1)/2次比较和交换
- **平均情况**：O(n²) - 对于随机排列的数组

## 4. 稳定性说明

冒泡排序是**稳定**的排序算法。因为当两个元素相等时，算法不会交换它们的位置（只有当前一个元素大于后一个元素时才交换），所以相等元素的相对顺序保持不变。

## 5. 动态示意图描述

以数组 [5, 3, 8, 6, 2] 为例：

**第一轮：**
1. 比较5和3 → 5>3 → 交换 → [3,5,8,6,2]
2. 比较5和8 → 5<8 → 不交换
3. 比较8和6 → 8>6 → 交换 → [3,5,6,8,2]
4. 比较8和2 → 8>2 → 交换 → [3,5,6,2,8]
   最大元素8已到位

**第二轮：**
1. 比较3和5 → 3<5 → 不交换
2. 比较5和6 → 5<6 → 不交换
3. 比较6和2 → 6>2 → 交换 → [3,5,2,6,8]
   次大元素6已到位

**第三轮：**
1. 比较3和5 → 3<5 → 不交换
2. 比较5和2 → 5>2 → 交换 → [3,2,5,6,8]
   第三大元素5已到位

**第四轮：**
1. 比较3和2 → 3>2 → 交换 → [2,3,5,6,8]
   数组完全有序

## 6. 典型应用场景

冒泡排序由于其简单性，主要用于：
- 教学目的，介绍排序算法的基本概念
- 小型数据集的排序（n < 100）
- 几乎已经有序的数据（此时接近O(n)）
- 内存受限的环境（因为它是原地排序，不需要额外空间）

## 对比与注意事项

**内存占用**：冒泡排序是原地排序算法，只需要O(1)的额外空间（用于交换元素）。

**常见实现错误**：
1. 边界条件处理不当（如数组长度为0或1时）
2. 内层循环的终止条件错误（应该是`n-1-i`而不是`n-1`）
3. 忘记添加提前退出的优化（`swapped`标志）
4. 使用错误的比较运算符（应该是`>`而不是`>=`以保持稳定性）

**测试代码示例（C++11/17特性）**：

```cpp
#include <iostream>
#include <vector>
#include <random>
#include <chrono>
#include <algorithm>

void testBubbleSort() {
    // 使用C++11随机数生成器
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> dis(1, 10000);
    
    // 生成1000个随机数
    std::vector<int> arr(1000);
    auto generate = [&](){ return dis(gen); };
    std::generate(arr.begin(), arr.end(), generate);
    
    // 使用C++11计时器
    auto start = std::chrono::high_resolution_clock::now();
    
    bubbleSort(arr);
    
    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
    
    // 检查是否已排序
    bool isSorted = std::is_sorted(arr.begin(), arr.end());
    
    std::cout << "排序" << (isSorted ? "成功" : "失败") 
              << "，耗时: " << duration.count() << " 毫秒" << std::endl;
}

int main() {
    testBubbleSort();
    return 0;
}
```