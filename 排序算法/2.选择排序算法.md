# 选择排序详解

## 1. 基本思想

选择排序(Selection Sort)是一种简单直观的排序算法。它的基本思想是：**每次从未排序的部分中选择最小（或最大）的元素，放到已排序部分的末尾**。通过不断缩小未排序部分的范围，最终完成整个数组的排序。

选择排序可以形象地理解为：在每一轮遍历中，"选择"当前未排序部分的最小元素，然后将其放到正确的位置。

## 2. 代码实现

```cpp
#include <iostream>
#include <vector>
#include <algorithm> // 用于std::swap

void selectionSort(std::vector<int>& arr) {
    int n = arr.size();
    for (int i = 0; i < n - 1; ++i) { // 外层循环控制已排序部分的末尾
        int minIndex = i; // 假设当前元素是最小的
        
        // 在未排序部分中寻找最小元素
        for (int j = i + 1; j < n; ++j) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j; // 更新最小元素的索引
            }
        }
        
        // 将找到的最小元素与当前元素交换
        if (minIndex != i) {
            std::swap(arr[i], arr[minIndex]);
        }
    }
}

int main() {
    std::vector<int> arr = {64, 25, 12, 22, 11};
    
    std::cout << "排序前: ";
    for (int num : arr) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
    
    selectionSort(arr);
    
    std::cout << "排序后: ";
    for (int num : arr) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
    
    return 0;
}
```

## 3. 时间复杂度分析

- **最好情况**：O(n²) - 即使数组已经有序，仍需进行n(n-1)/2次比较
- **最坏情况**：O(n²) - 数组逆序时同样需要n(n-1)/2次比较
- **平均情况**：O(n²) - 对于随机排列的数组

虽然时间复杂度相同，但选择排序通常比冒泡排序快，因为它每次只进行一次交换操作（冒泡排序可能需要多次交换）。

## 4. 稳定性说明

选择排序是**不稳定**的排序算法。考虑数组[5, 8, 5, 2, 9]，第一轮选择最小元素2时，会与第一个5交换，导致两个5的相对顺序改变。

## 5. 动态示意图描述

以数组 [29, 10, 14, 37, 13] 为例：

**第一轮：**
1. 初始最小元素索引为0(29)
2. 比较29和10 → 10更小 → minIndex=1
3. 比较10和14 → 10更小 → minIndex保持1
4. 比较10和37 → 10更小 → minIndex保持1
5. 比较10和13 → 10更小 → minIndex保持1
6. 交换arr[0]和arr[1] → [10,29,14,37,13]
   最小元素10已到位

**第二轮：**
1. 从索引1开始，初始minIndex=1(29)
2. 比较29和14 → 14更小 → minIndex=2
3. 比较14和37 → 14更小 → minIndex保持2
4. 比较14和13 → 13更小 → minIndex=4
5. 交换arr[1]和arr[4] → [10,13,14,37,29]
   次小元素13已到位

**第三轮：**
1. 从索引2开始，初始minIndex=2(14)
2. 比较14和37 → 14更小 → minIndex保持2
3. 比较14和29 → 14更小 → minIndex保持2
4. 无需交换 → [10,13,14,37,29]
   第三小元素14已在正确位置

**第四轮：**
1. 从索引3开始，初始minIndex=3(37)
2. 比较37和29 → 29更小 → minIndex=4
3. 交换arr[3]和arr[4] → [10,13,14,29,37]
   排序完成

## 6. 典型应用场景

选择排序适用于：
- 小规模数据的排序
- 当交换成本较高时（因为选择排序每轮最多交换一次）
- 对内存使用有严格限制的环境（原地排序，O(1)空间复杂度）
- 需要找到数组中前k个最小/最大元素的场景

## 对比与注意事项

**内存占用**：选择排序是原地排序算法，只需要O(1)的额外空间（用于交换元素和存储索引）。

**与冒泡排序比较**：
- 选择排序比冒泡排序更快，因为交换次数更少
- 冒泡排序是稳定的，而选择排序不稳定
- 两者时间复杂度相同，但选择排序实际性能更好

**常见实现错误**：
1. 内层循环的起始索引错误（应该是i+1而不是0）
2. 忘记在交换前检查minIndex是否改变
3. 外层循环的终止条件错误（应该是n-1而不是n）
4. 使用错误的比较方向（找最小元素用<，找最大元素用>）

**测试代码示例（C++11/17特性）**：

```cpp
#include <iostream>
#include <vector>
#include <random>
#include <chrono>
#include <algorithm>

void testSelectionSort() {
    // 使用C++11随机数生成器
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> dis(1, 10000);
    
    // 生成1000个随机数
    std::vector<int> arr(1000);
    auto generate = [&](){ return dis(gen); };
    std::generate(arr.begin(), arr.end(), generate);
    
    // 使用C++11计时器
    auto start = std::chrono::high_resolution_clock::now();
    
    selectionSort(arr);
    
    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
    
    // 检查是否已排序
    bool isSorted = std::is_sorted(arr.begin(), arr.end());
    
    std::cout << "排序" << (isSorted ? "成功" : "失败") 
              << "，耗时: " << duration.count() << " 毫秒" << std::endl;
}

int main() {
    testSelectionSort();
    return 0;
}
```