

## C++ 多目标追踪项目代码说明文档

### 1. 项目概述

程序采用双阶段匹配了处理逻辑，并结合了 **交互式多模型卡尔曼滤波器（Interacting Multiple Model Kalman Filter, IMM-KF）** 进行目标状态的预测。


### 2. 文件结构与核心模块


* **`main.cpp` - 主程序入口**
    * **职责:** 程序的启动、数据读取、流程控制和结果输出。
    * **流程:**
        1.  初始化 `TrackerInterface` (追踪器接口) 和 `TrackerVisualizer` (可视化工具)。
        2.  逐行读取 `result.txt` 文件中的检测数据。
        3.  使用正则表达式 `parseLine` 函数解析每行数据，提取出每个目标的边界框、类别、置信度和时间戳。
        4.  调用 `Tracker.feedOneFrame()` 将一帧的检测数据送入追踪器进行处理。
        5.  获取追踪性能指标（如 ID 切换率）。
        6.  调用 `Visualizer.drawFrame()` 将当前帧的追踪结果绘制成图像。
        7.  循环处理所有数据，最终生成 `IMM.avi` 视频文件。

* **`BYTETracker.cpp` & `STrack.cpp` - 追踪核心逻辑**
    * **`BYTETracker.cpp`:** 实现了 **ByteTrack** 算法的核心逻辑。`update` 函数是其关键，负责处理每一帧数据，完成“检测-追踪”的关联匹配。
    * **`STrack.cpp`:** 定义了单个追踪目标的数据结构 `STrack`（Tracklet）。它封装了目标的状态（如 `New`, `Tracked`, `Lost`, `Removed`）、`track_id`、边界框信息、生命周期以及与之绑定的 IMM 状态。

* **`IMMKalmanFilter.cpp` & 其他 KalmanFilter 文件 - 运动模型与状态估计**
    * **`IMMKalmanFilter.cpp`:** 实现了 **交互式多模型卡尔曼滤波器**。它不执行单一的运动假设，而是并行维护多个运动模型，并根据目标的实际运动情况动态调整各模型的权重。
    * **`kalmanFilter.cpp`:** 实现了标准的 **恒定速度 (Constant Velocity, CV)** 模型。适用于做匀速直线运动的目标。
    * **`KalmanFilterCA.cpp`:** 实现了 **恒定加速度 (Constant Acceleration, CA)** 模型。适用于做变速运动或机动的目标。
    * **`KalmanFilterStill.cpp`:** 实现了 **静止 (Still)** 模型。适用于几乎不动的目标。
    * 这些滤波器共同为 `STrack` 提供位置预测能力。

* **`TrackerInterface.cpp` - 追踪器接口**
    * **职责:** 作为上层应用 (`main.cpp`) 与底层追踪逻辑 (`BYTETracker`) 之间的桥梁，提供一个 API 接口。
    * 它封装了 `BYTETracker` 的实例化和调用细节，并将内部数据结构 `STrack` 转换为更通用的 `Track` 结构，简化了外部调用。



* **`TrackerStatistics.cpp` - 性能统计工具**
    * **职责:** 计算追踪过程中的关键性能指标，主要是 **ID 切换率 (ID Switch Rate)**。
    * 通过比较连续帧之间目标中心点的位置，它为场景中的目标建立一个临时的“虚拟 ID”。如果一个“虚拟 ID”在下一帧被分配了一个不同的 `track_id`，则计为一次 ID 切换。这个指标是衡量追踪目标丢失率

---

### 3. 核心算法详解

#### 3.1. 追踪流程

代码算法的核心思想是**充分利用高分和低分检测框**。传统方法通常会丢弃置信度低的检测框，但这可能导致被遮挡的目标丢失。代码通过一个两阶段的匹配策略来解决此问题。

**`BYTETracker::update` 函数执行流程:**

1.  **预处理:** 将当前帧的检测框根据置信度阈值 `track_thresh` (0.95) 分为**高分检测框 `detections`** 和**低分检测框 `detections_low`**。同时，将已有的轨迹分为 `tracked_stracks` (已确认) 和 `unconfirmed` (待确认)。

2.  **第一次关联 (高分匹配):**
    * 使用 IMM 卡尔曼滤波器预测所有 `tracked_stracks` 和 `lost_stracks` (暂时丢失的轨迹) 在当前帧的位置。
    * 计算预测框与**高分检测框**之间的 IoU (交并比) 代价矩阵。
    * 使用匈牙利算法 (`linear_assignment`) 进行最优匹配。
    * 匹配成功的轨迹用新的检测框更新其状态；其中，从 `lost_stracks` 中匹配成功的轨迹被重新激活（`re_activate`），放入 `refind_stracks` 列表。

3.  **第二次关联 (低分匹配):**
    * 将在第一次关联中**未匹配上的轨迹** (主要是被遮挡的轨迹)，与**低分检测框**进行匹配。
    * 被遮挡的目标其检测置信度通常会降低，利用这些低分框可以有效地找回它们，防止轨迹中断。
    * 匹配成功的轨迹同样被更新状态并被激活。
    * 此轮过后仍然未匹配的轨迹，如果其状态是 `Tracked`，则被标记为 `Lost`。

4.  **新轨迹初始化:**
    * 将在第一次关联中**未匹配上的高分检测框**，被认为是新出现的目标。
    * 如果其置信度高于 `high_thresh` (0.8)，则为其初始化一个新的 `STrack` 实例，并激活它。

5.  **轨迹生命周期管理:**
    * 更新所有轨迹列表。长时间处于 `Lost` 状态的轨迹 (超过 `max_time_lost` 帧) 会被标记为 `Removed` 并移除。
    * 最后，将所有处于 `Tracked` 状态且已激活的轨迹作为当前帧的最终追踪结果输出。

#### 3.2. IMM 交互式多模型卡尔曼滤波

为了应对目标复杂的运动模式，项目采用了 IMM 滤波器。

**工作原理:**
IMM 滤波器通过并行运行多个具有不同运动假设的卡尔曼滤波器（本项目中为 CV、CA、Still），并根据观测数据动态调整每个模型的置信度（概率），从而实现更精准和自适应的状态估计。

**核心步骤:**

1.  **交互/混合 (Interaction/Mixing):** 在预测步骤开始前，每个模型的当前状态会根据一个**模型转移概率矩阵** (`transition_probs_`)，与其他所有模型的状态进行加权融合。这相当于为每个模型准备一个“混合的”初始状态，包含了从其他模型转移过来的可能性。
2.  **模型独立滤波 (Model-Specific Filtering):** 每个独立的卡尔曼滤波器（CV, CA, Still）使用混合后的状态执行自己的预测和更新步骤。
3.  **模型概率更新 (Model Probability Update):** 在更新步骤中，计算每个模型产生实际观测值的“似然度”。根据这个似然度和之前的模型概率，更新每个模型在当前时刻的置信度（概率）。
4.  **状态融合 (State Fusion):** 最终输出的轨迹状态（位置、速度等）是所有模型状态的加权平均值，权重就是每个模型更新后的概率。

通过这种方式，当一个目标做匀速运动时，CV 模型的概率会最高；当它开始加速或转弯时，CA 模型的概率会迅速上升，使得追踪器能够快速适应运动状态的变化。

