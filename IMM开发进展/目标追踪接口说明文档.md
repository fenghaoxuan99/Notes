### 冯浩轩  
### 时间：2025.7.31   
### 版本：V3.0.1


##  `TrackerInterface` 接口文档

#### 1. **接口初始化**
```cpp
TrackerInterface myTracker;
```
- **说明**：无参构造函数，初始化跟踪器
- **内部状态**：
  - `_frame_id`：帧计数器（从0开始）
  - `_timestamp`：时间戳记录器（毫秒级精度）

---

#### 2. **正常追踪接口**
```cpp
std::vector<Track> feedOneFrame(const std::vector<Object> &objects, double timestamp);
```
##### 功能：
处理单帧检测结果，更新目标状态并返回激活轨迹

##### 参数说明：
| 参数        | 类型                      | 说明                          |
|-------------|--------------------------|-----------------------------|
| `objects`   | `const std::vector<Object>&` | 当前帧检测结果集合             |
| `timestamp` | `double`                 | **毫秒级**时间戳（如`1680000000.0`）|

##### 内部处理流程：
1. 帧计数器 `_frame_id` 自增
2. 计算时间间隔：`interval_time = (当前timestamp - 上一帧timestamp) / 1000.0`（秒）
3. 调用 `tracker.update()` 更新轨迹状态
4. 过滤非激活轨迹（`is_activated=false` 或 `state=Removed`）

##### 返回值：
`std::vector<Track>` 激活轨迹集合

##### Object结构体说明：
```cpp
struct Object
{
    std::vector<float> rect;  // [x, y, w, h] 格式
    int label;                // 目标类别标签
    float prob;               // 检测置信度（必须>0）
};
```

##### Track结构体说明：
```cpp
struct Track
{
    std::vector<float> tlwh;  // [x, y, w, h] 当前目标框
    float score;              // 跟踪置信度（0.0~1.0）
    int label;                // 继承检测结果的类别标签
    int track_id;             // 唯一轨迹ID（>0）
    int state;                // 运动状态 1匀速 2加速 3静止
};
```

---

#### 3. **预测接口**
```cpp
std::vector<Track> predict_frame(double interval_time);
```
##### 功能：
基于当前轨迹进行纯预测（**不更新状态**，**不做数据关联**）

##### 参数说明：
| 参数           | 类型      | 说明                 |
|----------------|----------|---------------------|
| `interval_time` | `double` | 预测时间间隔（秒）   |

##### 返回值：
`std::vector<Track>` 预测后的轨迹集合

---

#### 4. **ID切换率获取接口**
```cpp
float get_id_switch_rate() const;
```
##### 功能：
计算ID切换比率 = ID切换次数 / 总轨迹数  
（用于评估跟踪稳定性）

---

#### 5. **资源释放接口**
```cpp
void release();
```
##### 功能：
清空跟踪器内部所有轨迹缓存

---


### 完整头文件
```cpp
#ifndef TRACKER_INTERFACE_H
#define TRACKER_INTERFACE_H

#include <vector>
#include "BYTETracker.h"

struct Track {
    std::vector<float> tlwh;  // [x, y, w, h]
    float score = 0.0f;       // 跟踪置信度
    int label = -1;           // 类别标签
    int track_id = -1;        // 轨迹ID
};

class TrackerInterface {
public:
    TrackerInterface();
    std::vector<Track> feedOneFrame(const std::vector<Object> &objects, double timestamp);
    std::vector<Track> predict_frame(double interval_time);
    void release();
    float get_id_switch_rate() const;
    BYTETracker& get_tracker();

private:
    std::vector<Track> convert_to_public_tracks(const std::vector<STrack> &internal_tracks);
    BYTETracker tracker;
    int _frame_id;
    double _timestamp;
};

#endif
```

---

### Demo 使用示例
```cpp
#include "TrackerInterface.h"
#include <iostream>

int main() {
    // 1. 初始化跟踪器
    TrackerInterface tracker;
    
    // 2. 模拟输入数据（连续3帧）
    for(int frame = 0; frame < 3; ++frame) {
        std::vector<Object> detections;
        
        // 添加模拟检测结果 (x,y,w,h,label,prob)
        detections.push_back({{10.0f, 20.0f, 30.0f, 40.0f}, 0, 0.9f});
        detections.push_back({{50.0f, 60.0f, 25.0f, 35.0f}, 2, 0.85f});
        
        // 3. 处理当前帧 (时间戳单位：毫秒)
        double timestamp = 1000.0 * (frame + 1); // 模拟时间戳
        auto tracks = tracker.feedOneFrame(detections, timestamp);
        
        // 4. 输出跟踪结果
        std::cout << "Frame " << frame << " Tracks: " << tracks.size() << std::endl;
        for (const auto& track : tracks) {
            std::cout << "  Track ID: " << track.track_id 
                      << " Box: [" << track.tlwh[0] << ", " << track.tlwh[1]
                      << ", " << track.tlwh[2] << ", " << track.tlwh[3] << "]"
                      << " Label: " << track.label
                      << " Score: " << track.score << std::endl;
        }
    }
    
    // 5. 预测0.5秒后的状态
    std::cout << "\nPredicting after 0.5s:" << std::endl;
    auto predicted = tracker.predict_frame(0.5);
    for (const auto& track : predicted) {
        std::cout << "  Predicted ID: " << track.track_id 
                  << " Position: " << track.tlwh[0] << ", " << track.tlwh[1] << std::endl;
    }
    
    // 6. 获取ID切换率
    std::cout << "\nID Switch Rate: " << tracker.get_id_switch_rate() << std::endl;
    
    // 7. 释放资源
    tracker.release();
    return 0;
}
```
