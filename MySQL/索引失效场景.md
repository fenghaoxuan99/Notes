
## MySQL 索引失效情况详解

索引是提升 MySQL 查询性能的核心机制，但在特定场景下索引可能失效，导致全表扫描和性能下降。以下是常见索引失效情况及解决方案：

---

### 一、违反最左前缀原则（复合索引）
**场景**：复合索引未从最左列开始使用  
**示例**：索引 `idx_name_age(name, age)`  
```sql
-- ✅ 有效：使用最左列 name
SELECT * FROM users WHERE name = 'Alice';

-- ✅ 有效：使用完整索引列
SELECT * FROM users WHERE name = 'Bob' AND age = 25;

-- ❌ 失效：跳过 name 直接使用 age
SELECT * FROM users WHERE age = 30;

-- ❌ 失效：未连续使用索引列
SELECT * FROM users WHERE name = 'Charlie' AND salary = 5000; -- salary 不在索引中
```

**解决方案**：  
1. 调整查询条件顺序  
2. 创建新索引 `(age)` 或 `(salary, name)` 等  
3. 使用索引覆盖（仅查询索引列）

---

### 二、对索引列进行计算或函数操作
**场景**：在 WHERE 子句中对索引列进行运算  
**示例**：索引 `idx_birthday(birthday)`  
```sql
-- ❌ 失效：使用 YEAR() 函数
SELECT * FROM users WHERE YEAR(birthday) = 1990;

-- ❌ 失效：数学运算
SELECT * FROM products WHERE price * 0.9 > 100;
```

**解决方案**：  
```sql
-- ✅ 有效：转为范围查询
SELECT * FROM users 
WHERE birthday BETWEEN '1990-01-01' AND '1990-12-31';

-- ✅ 有效：调整运算位置
SELECT * FROM products WHERE price > 100 / 0.9;
```

---

### 三、隐式类型转换
**场景**：查询值与列数据类型不匹配  
**示例**：`phone` 列是 VARCHAR，但用数字查询  
```sql
-- ❌ 失效：字符串列用数字比较
SELECT * FROM users WHERE phone = 13800138000; 

-- ❌ 失效：日期列用字符串比较（依赖格式）
SELECT * FROM orders WHERE order_date = '2023-01-01'; -- 若 order_date 是 DATETIME
```

**解决方案**：  
```sql
-- ✅ 有效：统一数据类型
SELECT * FROM users WHERE phone = '13800138000';

-- ✅ 有效：使用 CAST() 或正确格式
SELECT * FROM orders WHERE order_date = CAST('2023-01-01' AS DATE);
```

---

### 四、LIKE 通配符前置
**场景**：`%` 出现在 LIKE 模式开头  
**示例**：索引 `idx_name(name)`  
```sql
-- ❌ 失效：开头通配符
SELECT * FROM users WHERE name LIKE '%son';

-- ✅ 有效：结尾通配符（走索引）
SELECT * FROM users WHERE name LIKE 'John%';
```

**解决方案**：  
1. 避免前置 `%`  
2. 使用全文索引（FULLTEXT）  
3. 数据预处理（如冗余列存储反转字符串）

---

### 五、OR 条件使用不当
**场景**：OR 连接的列存在无索引项  
**示例**：索引 `idx_age(age)`，但 `salary` 无索引  
```sql
-- ❌ 失效：salary 无索引导致全表扫描
SELECT * FROM employees 
WHERE age > 30 OR salary > 10000;
```

**解决方案**：  
```sql
-- ✅ 有效：拆分为 UNION ALL
SELECT * FROM employees WHERE age > 30
UNION ALL
SELECT * FROM employees WHERE salary > 10000;

-- ✅ 添加 salary 索引
CREATE INDEX idx_salary ON employees(salary);
```

---

### 六、范围查询后索引中断
**场景**：复合索引中范围查询后的列失效  
**示例**：索引 `idx_age_dept_salary(age, dept, salary)`  
```sql
-- ❌ dept 和 salary 失效（age 是范围查询）
SELECT * FROM employees 
WHERE age > 25 AND dept = 'IT' AND salary > 8000;
```

**解决方案**：  
1. 调整索引顺序：`(dept, age, salary)`  
2. 拆分查询条件  
3. 使用覆盖索引

---

### 七、使用 NOT IN / != / <>
**场景**：否定条件导致全表扫描  
**示例**：索引 `idx_status(status)`  
```sql
-- ❌ 通常失效（除非低基数）
SELECT * FROM orders WHERE status != 'completed';

-- ❌ 失效（NOT IN 同理）
SELECT * FROM users WHERE id <> 100;
```

**解决方案**：  
```sql
-- ✅ 改写为范围查询
SELECT * FROM orders 
WHERE status IN ('pending', 'cancelled');

-- ✅ 使用 EXISTS 替代
SELECT * FROM users u
WHERE NOT EXISTS (
  SELECT 1 FROM blacklist b WHERE b.user_id = u.id
);
```

---

### 八、索引列参与表达式比较
**场景**：索引列与表达式比较  
**示例**：索引 `idx_created_at(created_at)`  
```sql
-- ❌ 失效：列参与计算
SELECT * FROM logs 
WHERE created_at + INTERVAL 1 DAY > NOW();
```

**解决方案**：  
```sql
-- ✅ 有效：调整表达式位置
SELECT * FROM logs 
WHERE created_at > NOW() - INTERVAL 1 DAY;
```

---

### 九、优化器选择全表扫描
**场景**：数据量小或索引选择性差  
**示例**：  
```sql
-- 表仅 100 行，即使有索引
SELECT * FROM small_table WHERE name = 'test';

-- 索引列重复值过多（如 gender 列）
SELECT * FROM users WHERE gender = 'F'; -- 假设 50% 数据
```

**解决方案**：  
1. 使用 `FORCE INDEX` 强制索引  
2. 优化表统计信息：`ANALYZE TABLE table_name`  
3. 对低基数列使用复合索引

---

### 十、其他失效场景
1. **IS NULL / IS NOT NULL**  
   ```sql
   -- 可能失效（依赖数据分布）
   SELECT * FROM users WHERE phone IS NULL;
   ```
   **方案**：设置默认值替代 NULL

2. **JOIN 字段字符集/排序规则不一致**  
   ```sql
   -- 字符集不同导致失效
   SELECT * FROM t1 JOIN t2 
   ON t1.name = t2.name COLLATE utf8_general_ci; 
   ```
   **方案**：统一字符集和排序规则

3. **索引列使用函数**  
   ```sql
   -- ❌ 失效
   SELECT * FROM users WHERE LOWER(name) = 'alice';
   ```
   **方案**：存储预处理数据或使用函数索引（MySQL 8.0+）

---

### 诊断工具：EXPLAIN
使用 `EXPLAIN` 分析查询计划：
```sql
EXPLAIN SELECT * FROM users WHERE name LIKE '%son';
```
关键指标：
- `type`：`ALL` 表示全表扫描  
- `key`：`NULL` 表示未使用索引  
- `Extra`：`Using where; Using filesort` 需优化

---

### 最佳实践总结
1. **复合索引**：严格遵循最左前缀原则  
2. **避免计算**：不在索引列上使用函数或表达式  
3. **类型匹配**：确保查询值与列类型一致  
4. **LIKE 优化**：避免前置通配符 `%`  
5. **OR 改写**：用 `UNION ALL` 替代包含无索引列的 OR  
6. **范围查询**：置于复合索引最后列  
7. **定期维护**：`ANALYZE TABLE` 更新统计信息  
8. **覆盖索引**：优先选择 `SELECT` 索引列

通过理解这些场景并配合 `EXPLAIN` 分析，可显著提升查询性能，避免索引失效问题。