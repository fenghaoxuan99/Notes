# 多版本并发控制(MVCC)与间隙锁(Next-Key Locking)防止幻影读的解释

## 幻影读(Phantom Read)问题

幻影读是指在同一事务内，连续执行两次相同的查询，第二次查询看到了第一次查询没有看到的新行(这些行被称为"幻影行")。这发生在其他事务在两次查询之间插入了新数据的情况下。

## MVCC与Next-Key Locking的协同作用

### 1. 多版本并发控制(MVCC)

MVCC通过以下方式工作：
- 为每个事务维护一个"快照"视图
- 保留数据的多个版本(通过版本号或时间戳区分)
- 读操作只能看到在事务开始前已提交的数据版本

MVCC本身可以解决**不可重复读**问题，但对于幻影读，仅靠MVCC是不够的，因为新插入的行没有历史版本，MVCC无法过滤这些新插入的行。

### 2. 间隙锁(Next-Key Locking)

Next-Key Locking是InnoDB中解决幻影读的主要机制，它实际上是：
- **记录锁(Record Lock)**：锁定索引中的具体记录
- **间隙锁(Gap Lock)**：锁定索引记录之间的间隙

Next-Key Locking将两者结合，锁定记录及其前面的间隙。例如，对于索引值10和20，Next-Key Lock会锁定(负无穷,10], (10,20], (20,正无穷)这样的区间。

### 协同工作机制

当使用可重复读(REPEATABLE READ)隔离级别时：
1. **读取操作**：使用MVCC提供一致性视图，避免读取未提交或后提交的数据
2. **写入操作**：使用Next-Key Locking锁定相关范围，防止其他事务插入可能成为"幻影行"的新记录

例如，当执行`SELECT * FROM t WHERE id > 10 FOR UPDATE`时：
- 会锁定所有id>10的记录及其后面的间隙
- 其他事务无法在这些锁定范围内插入新记录
- 从而保证了在当前事务中再次执行相同查询时，不会看到新插入的行

## 总结

MVCC+Next-Key Locking的组合：
- MVCC解决了读-写冲突，提供一致性视图
- Next-Key Locking解决了写-写冲突，防止新行插入造成幻影读
- 两者协同工作，在可重复读隔离级别下既保证了并发性能，又避免了幻影读问题