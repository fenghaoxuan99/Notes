
## MySQL 索引核心知识点详解

**索引定义：** 索引是帮助存储引擎（如 InnoDB）快速获取数据的一种**数据结构**，本质是数据的目录。它以空间换时间，提升查询效率。

**索引分类：**

| 分类角度       | 索引类型                         | 核心特点                                                                                                                               |
| :------------- | :------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------- |
| **数据结构**   | **B+Tree 索引**                  | **默认且最常用**。多叉树，非叶节点存索引值，叶节点存数据（主键索引）或主键值（二级索引），叶节点双向链表连接。支持高效范围查询和排序。 |
|                | Hash 索引                       | 等值查询极快（O(1)），**不支持范围查询**。InnoDB 不支持显式 Hash 索引（有自适应 Hash）。                                               |
|                | Full-Text 索引                  | 用于全文搜索。                                                                                                                         |
| **物理存储**   | **聚簇索引 (Clustered Index)**   | **即主键索引**。叶节点存储整行数据。一张表只有一个。                                                                                   |
|                | **二级索引 (Secondary Index)**   | **辅助索引**。叶节点存储主键值。查询非索引列需**回表**（通过主键值回聚簇索引查完整数据）。                                             |
| **字段特性**   | 主键索引 (Primary Key)           | 建立在主键上，NOT NULL，唯一，一张表一个。                                                                                             |
|                | 唯一索引 (Unique Index)          | 建立在 UNIQUE 字段上，列值唯一，允许 NULL（但 NULL 只能出现一次），一张表可多个。                                                      |
|                | 普通索引 (Index)                 | 建立在普通字段上，无唯一性约束。                                                                                                       |
|                | 前缀索引 (Prefix Index)          | 对字符类型字段前 N 个字符建立索引，节省空间，但**不支持 ORDER BY 和覆盖索引**。                                                         |
| **字段个数**   | 单列索引                         | 建立在单个列上。                                                                                                                       |
|                | **联合索引 (Composite Index)**   | 建立在多个列上。**遵循最左匹配原则**。                                                                                                 |

**为什么 InnoDB 选择 B+Tree？**

1.  **vs B树：**
    *   B+Tree 非叶节点**不存数据**，故单个节点能存更多索引键，相同 I/O 次数下查询范围更大（树更矮胖）。
    *   B+Tree 叶节点**双向链表连接**，**天然支持高效范围查询和顺序访问**。B 树范围查询需复杂遍历。
2.  **vs 二叉树：**
    *   B+Tree 是**多叉树**（d > 100），千万级数据高度通常仅 3-4 层，查询只需 3-4 次 I/O。
    *   二叉树每个节点最多 2 子节点，树高更高（O(logN)），I/O 次数更多。
3.  **vs Hash：**
    *   Hash **仅适合等值查询**（O(1)）。
    *   B+Tree **支持高效的范围查询、排序和前缀匹配**，适用场景更广。

**联合索引与最左匹配原则**

*   **结构：** 联合索引 `(a, b, c)` 的 B+Tree 先按 `a` 排序，`a` 相同再按 `b` 排序，`b` 相同再按 `c` 排序。
*   **最左匹配原则：** 查询条件必须**从索引最左列开始**且**连续**（或使用前缀），才能充分利用索引。
    *   **有效：** `WHERE a=1`; `WHERE a=1 AND b=2`; `WHERE a=1 AND b=2 AND c=3`; `WHERE a=1 AND b>2` (仅 `a`, `b` 有效)
    *   **失效：** `WHERE b=2`; `WHERE c=3`; `WHERE b=2 AND c=3`; `WHERE a>1 AND b=2` (仅 `a` 有效，`a` 范围查询后 `b` 无序)
*   **范围查询的停止点：** 联合索引遇到 `>`、`<` 范围查询时，**其后的索引列通常失效**。但 `>=`、`<=`、`BETWEEN`、`LIKE 'prefix%'` **不会立即停止匹配**，其后的等值条件可能仍有效（需看执行计划 `key_len`）。

**关键概念补充**

1.  **回表：** 通过二级索引查到主键值后，**再回聚簇索引查询完整行数据**的过程。影响性能。
2.  **覆盖索引：** **查询的字段都包含在索引中**（或主键），无需回表。性能最佳。如 `SELECT id FROM product WHERE product_no = '0002'` (索引 `(product_no)` 覆盖 `id`)。
3.  **索引下推 (ICP - Index Condition Pushdown, MySQL 5.6+)：**
    *   在**遍历联合索引时**，对索引中包含的字段（即使不满足最左匹配）先做条件判断，**过滤掉不满足条件的记录**，减少回表次数。
    *   `Extra` 列显示 `Using index condition` 表示使用。
4.  **索引区分度：**
    *   公式：`COUNT(DISTINCT column) / COUNT(*)`。值越接近 1，区分度越高，索引效果越好。
    *   建立联合索引时，**区分度高的字段应放在前面**。
5.  **索引用于排序：** `ORDER BY` 字段若在索引中且满足最左匹配，可避免 `filesort`。如 `SELECT * FROM orders WHERE status=1 ORDER BY create_time`，建立 `(status, create_time)` 索引。

**何时创建索引？**

*   **适用场景：**
    *   字段有**唯一性**约束（如商品编码）。
    *   经常出现在 **`WHERE`** 子句中的字段。
    *   经常用于 **`GROUP BY`** 和 **`ORDER BY`** 的字段（利用索引有序性）。
    *   用于**关联查询**的字段（外键）。
*   **不适用场景：**
    *   `WHERE`/`GROUP BY`/`ORDER BY` 中**用不到的字段**。
    *   **数据重复度高**且分布均匀的字段（如性别）。优化器可能直接全表扫描。
    *   **表数据量非常小**。
    *   **频繁更新**的字段（维护索引代价高）。
    *   **长文本字段**（考虑前缀索引或全文索引）。

**优化索引方法**

1.  **前缀索引：** 减小索引大小，提高页利用率。牺牲排序、覆盖索引能力。
2.  **覆盖索引：** 避免回表，极大提升性能。设计索引时考虑查询需求。
3.  **主键自增：**
    *   保证新数据**顺序追加**到 B+Tree 尾部，避免**页分裂**（随机插入导致移动数据、空间碎片）。
    *   主键长度尽量小（影响二级索引叶节点大小）。
4.  **索引列设为 NOT NULL：**
    *   简化优化器工作。
    *   避免存储 `NULL` 值（额外空间，`NULL` 值比较更复杂）。
5.  **防止索引失效：**
    *   **左模糊/全模糊：** `LIKE '%xx'` / `LIKE '%xx%'`。
    *   **索引列运算/函数/类型转换：** `WHERE YEAR(create_time)=2023`, `WHERE price+10>100`。
    *   **违反最左匹配原则。**
    *   **OR 条件不当：** `WHERE a=1 OR b=2` (若 `b` 无索引，则 `a` 索引也失效)。
    *   **优化器放弃：** 当优化器判断全表扫描更快时（如数据少、区分度极低）。

**查看执行计划 (`EXPLAIN`) 关键字段：**

*   **`type` (效率降序)：**
    *   `const`/`eq_ref` > `ref` > `range` > `index` > `ALL` (全表扫描，最差)。目标至少达到 `range`。
*   **`key`：** 实际使用的索引。`NULL` 表示未用索引。
*   **`key_len`：** 使用的索引长度（字节）。可判断使用了联合索引中的几列。
*   **`rows`：** 预估扫描行数。
*   **`Extra` (重要提示)：**
    *   `Using filesort`：需额外排序（避免）。
    *   `Using temporary`：需创建临时表（如 `GROUP BY` 无索引，避免）。
    *   `Using index`：使用了覆盖索引（好）。
    *   `Using index condition`：使用了索引下推（好）。

**总结：** 理解 B+Tree 结构、聚簇/二级索引区别、回表、覆盖索引、联合索引的最左匹配原则及其边界（范围查询）、索引下推、索引失效场景是掌握 MySQL 索引的核心。合理设计和使用索引是优化数据库查询性能的关键。