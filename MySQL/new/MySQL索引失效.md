
**核心问题：MySQL 索引失效有哪些常见场景？**

**背景说明：**
建立索引能提升查询速度，但某些查询写法会导致索引失效，转而进行全表扫描，严重影响性能。以下是6种常见的索引失效场景及其原因分析（基于 MySQL 8.0.26, InnoDB 引擎）。

---

**索引失效的 6 种场景及原因分析：**

1.  **对索引字段使用左模糊或左右模糊匹配 (`LIKE '%xx'` 或 `LIKE '%xx%'`)**
    *   **现象：** `SELECT * FROM t_user WHERE name LIKE '%林';` (假设 `name` 是二级索引) 会导致全表扫描 (`type=ALL`)。
    *   **原因：** 索引 B+ 树是按索引值**有序存储**的，只能高效进行**前缀匹配**。左模糊或左右模糊无法确定匹配的起始索引值。
    *   **补充：** 右模糊 (`LIKE '林%'`) **可以**有效利用索引 (`type=range`)。

2.  **对索引字段使用函数**
    *   **现象：** `SELECT * FROM t_user WHERE LENGTH(name)=6;` (假设 `name` 是二级索引) 会导致全表扫描 (`type=ALL`)。
    *   **原因：** 索引存储的是字段的**原始值**，而非函数计算后的值。使用函数后，无法直接利用索引的有序性进行查找。
    *   **补充：** MySQL 8.0+ 支持**函数索引 (Function-Based Index)**，可对函数计算结果建立索引：`ALTER TABLE t_user ADD KEY idx_name_length ((LENGTH(name)));`，之后 `WHERE LENGTH(name)=6` 即可走索引。

3.  **对索引字段进行表达式计算**
    *   **现象：** `SELECT * FROM t_user WHERE id + 1 = 10;` (假设 `id` 是主键索引) 会导致全表扫描 (`type=ALL`)。
    *   **原因：** 索引存储的是字段的**原始值**，而非表达式计算后的值 (`id + 1`)。查询引擎需要读取所有行的原始值进行计算比较。
    *   **补充：** 将表达式移至等号另一边 (`WHERE id = 10 - 1`) 即可避免计算，正常走索引。

4.  **对索引字段进行隐式类型转换**
    *   **现象：**
        *   **场景 A (失效)：** `SELECT * FROM t_user WHERE phone = 1300000001;` (假设 `phone` 是 `VARCHAR` 类型的二级索引) 会导致全表扫描 (`type=ALL`)。
        *   **场景 B (有效)：** `SELECT * FROM t_user WHERE id = '1';` (假设 `id` 是 `INT` 类型的主键索引) 可以走索引 (`type=const/ref`)。
    *   **原因：**
        *   MySQL 在比较字符串和数字时，**默认将字符串转为数字**。
        *   **场景 A 等效于：** `SELECT ... WHERE CAST(phone AS SIGNED INT) = 1300000001;`。这相当于对索引字段 `phone` 使用了 `CAST` 函数，触发了场景2的失效原因。
        *   **场景 B 等效于：** `SELECT ... WHERE id = CAST('1' AS SIGNED INT);`。转换发生在输入参数 `'1'` 上，索引字段 `id` 本身未受影响，故可走索引。
    *   **关键点：** 失效发生在**索引字段是字符串类型**而**输入条件是数字**时，因为转换函数作用在了索引列上。

5.  **联合索引未遵循最左匹配原则**
    *   **现象：** 对于联合索引 `(a, b, c)`：
        *   有效：`WHERE a=1`, `WHERE a=1 AND b=2`, `WHERE a=1 AND b=2 AND c=3` (顺序无关紧要，优化器会调整)。
        *   **失效：** `WHERE b=2`, `WHERE c=3`, `WHERE b=2 AND c=3` (缺少最左列 `a`)。
    *   **原因：** 联合索引的数据按**第一列 (`a`) 排序**，第一列相同时再按第二列 (`b`) 排序，以此类推。跳过最左列直接查询后续列，无法利用索引的有序性。
    *   **补充 - 索引下推 (Index Condition Pushdown, ICP, MySQL 5.6+)：**
        *   对于 `WHERE a=1 AND c=3` (缺少中间列 `b`)：
            *   **MySQL 5.5：** 仅用索引 `a=1` 定位记录，回表读取完整行数据后，再在 Server 层过滤 `c=3`。
            *   **MySQL 5.6+：** 存储引擎层在遍历索引 `(a, b, c)` 时，会利用索引中已有的 `c` 列值进行 `c=3` 的判断 (`Using index condition`)，将过滤提前到回表前，减少回表次数，提升性能。**但这仍属于索引范围扫描 (`a=1`)，并非完全利用联合索引的所有列进行高效查找。**

6.  **WHERE 子句中 OR 条件使用不当**
    *   **现象：** `SELECT * FROM t_user WHERE id = 1 OR age = 18;` (假设 `id` 是主键索引，`age` 是**非索引**列) 会导致全表扫描 (`type=ALL`)。
    *   **原因：** OR 条件要求满足其一即可。如果 OR 后的条件列 (`age`) 没有索引，即使 OR 前的条件列 (`id`) 有索引，优化器也无法仅靠一个索引高效完成查询（需要检查所有满足 `id=1` 或 `age=18` 的行），只能选择全表扫描。
    *   **解决方案：** 为 OR 条件中**所有涉及的列**创建索引。例如，将 `age` 也设为索引后，查询会使用 `index merge` (如 `type=index_merge`, `Extra=Using union(id, idx_age); Using where`)，分别扫描两个索引再合并结果，避免全表扫描。

---

**总结 (索引失效的核心原因)：**

1.  **破坏有序性：** 模糊查询（左/左右）、函数、表达式计算、隐式转换（导致函数作用在索引列）都破坏了索引存储的原始值的有序性，无法利用 B+ 树的排序查找优势。
2.  **跳过最左列：** 联合索引必须包含最左列才能有效利用其结构。
3.  **OR 引入非索引列：** OR 条件要求所有可能路径都高效，非索引列的存在迫使全表扫描。