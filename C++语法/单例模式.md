# C++ 单例模式深度解析与实践指南

## 一、单例模式核心概念

单例模式（Singleton Pattern）是一种创建型设计模式，确保一个类只有一个实例，并提供全局访问点。这种模式在需要控制资源访问或管理全局状态时特别有用。

### 设计原则
1. **单一实例原则**：保证类只有一个实例存在
2. **全局访问原则**：提供统一的访问接口
3. **延迟初始化原则**（可选）：仅在需要时创建实例

## 二、完整实现方案

### 1. 经典实现（线程安全版本）

```cpp
#include <mutex>
#include <memory>

class Singleton {
private:
    static std::unique_ptr<Singleton> instance;
    static std::mutex mutex;
    
    // 私有构造函数防止外部实例化
    Singleton() = default;
    
    // 禁用拷贝和赋值
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;

public:
    // 获取单例实例
    static Singleton& getInstance() {
        if (!instance) {
            std::lock_guard<std::mutex> lock(mutex);
            if (!instance) {
                instance.reset(new Singleton());
            }
        }
        return *instance;
    }

    // 示例方法
    void doSomething() {
        // 业务逻辑
    }
};

// 静态成员初始化
std::unique_ptr<Singleton> Singleton::instance = nullptr;
std::mutex Singleton::mutex;
```

### 2. C++11 最优实现（Meyers' Singleton）

```cpp
class Singleton {
private:
    Singleton() = default;
    ~Singleton() = default;
    
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;

public:
    static Singleton& getInstance() {
        static Singleton instance;  // 线程安全初始化
        return instance;
    }
    
    // 业务方法
    void businessMethod() {
        // 实现业务逻辑
    }
};
```

## 三、线程安全深度分析

### 线程安全实现对比

| 实现方式            | 线程安全保证                          | 性能影响 | 适用场景               |
|---------------------|---------------------------------------|----------|------------------------|
| 饿汉式              | 程序启动时初始化，天然安全            | 高       | 初始化耗时少的场景     |
| 双重检查锁定        | 首次访问时加锁                        | 中       | C++11 之前版本         |
| Meyers' Singleton   | 依赖C++11的局部静态变量线程安全保证    | 低       | C++11及以后版本        |
| std::call_once      | 使用call_once保证只初始化一次          | 中       | 需要显式控制初始化的场景 |

### 最佳实践建议

1. **C++11及以上版本**：优先使用Meyers' Singleton实现
2. **旧版本C++**：使用双重检查锁定模式
3. **需要明确控制销毁**：考虑使用std::shared_ptr管理实例

## 四、实际应用案例

### 1. 全局配置管理器

```cpp
class ConfigManager {
private:
    std::unordered_map<std::string, std::string> configs;
    static ConfigManager& getInstance() {
        static ConfigManager instance;
        return instance;
    }
    
    ConfigManager() {
        // 加载默认配置
        configs["log_level"] = "info";
        configs["timeout"] = "5000";
    }

public:
    // 禁止拷贝
    ConfigManager(const ConfigManager&) = delete;
    ConfigManager& operator=(const ConfigManager&) = delete;
    
    static std::string getConfig(const std::string& key) {
        auto& inst = getInstance();
        if (inst.configs.find(key) != inst.configs.end()) {
            return inst.configs.at(key);
        }
        return "";
    }
    
    static void setConfig(const std::string& key, const std::string& value) {
        auto& inst = getInstance();
        inst.configs[key] = value;
    }
};

// 使用示例
void initSystem() {
    ConfigManager::setConfig("log_level", "debug");
    std::cout << "Timeout: " << ConfigManager::getConfig("timeout");
}
```

### 2. 数据库连接池

```cpp
class DatabasePool {
private:
    std::vector<DatabaseConnection*> connections;
    static DatabasePool& getInstance() {
        static DatabasePool instance;
        return instance;
    }
    
    DatabasePool() {
        // 初始化连接池
        for (int i = 0; i < 10; ++i) {
            connections.push_back(new DatabaseConnection());
        }
    }
    
    ~DatabasePool() {
        for (auto conn : connections) {
            delete conn;
        }
    }

public:
    DatabasePool(const DatabasePool&) = delete;
    DatabasePool& operator=(const DatabasePool&) = delete;
    
    static DatabaseConnection* getConnection() {
        auto& inst = getInstance();
        if (inst.connections.empty()) {
            throw std::runtime_error("No available connections");
        }
        auto conn = inst.connections.back();
        inst.connections.pop_back();
        return conn;
    }
    
    static void releaseConnection(DatabaseConnection* conn) {
        auto& inst = getInstance();
        inst.connections.push_back(conn);
    }
};

// 使用示例
void queryData() {
    auto conn = DatabasePool::getConnection();
    try {
        conn->executeQuery("SELECT * FROM users");
        DatabasePool::releaseConnection(conn);
    } catch (...) {
        DatabasePool::releaseConnection(conn);
        throw;
    }
}
```

## 五、高级主题与陷阱规避

### 1. 单例的销毁问题

**问题**：单例对象何时销毁？如何保证销毁顺序安全？

**解决方案**：
```cpp
class SafeSingleton {
private:
    static SafeSingleton& getInstance() {
        static SafeSingleton instance;
        return instance;
    }
    
    SafeSingleton() = default;
    ~SafeSingleton() {
        // 确保依赖资源先释放
    }
    
    // 防止静态对象销毁后再次访问
    static bool& isDestroyed() {
        static bool destroyed = false;
        return destroyed;
    }

public:
    static void doSomething() {
        if (isDestroyed()) {
            throw std::runtime_error("Singleton already destroyed");
        }
        getInstance().internalDoSomething();
    }

private:
    void internalDoSomething() {
        // 实际实现
    }
};
```

### 2. 单例与依赖注入

**问题**：单例模式使代码耦合度高，难以测试

**解决方案**：使用接口和依赖注入

```cpp
class ILogger {
public:
    virtual ~ILogger() = default;
    virtual void log(const std::string& message) = 0;
};

class ConsoleLogger : public ILogger {
public:
    static ConsoleLogger& getInstance() {
        static ConsoleLogger instance;
        return instance;
    }
    
    void log(const std::string& message) override {
        std::cout << message << std::endl;
    }
};

class Service {
private:
    ILogger& logger;
    
public:
    // 通过构造函数注入依赖
    explicit Service(ILogger& logger = ConsoleLogger::getInstance()) 
        : logger(logger) {}
    
    void doWork() {
        logger.log("Service working...");
    }
};

// 测试时可以使用mock
class MockLogger : public ILogger {
public:
    MOCK_METHOD(void, log, (const std::string&), (override));
};

TEST(ServiceTest, DoWorkTest) {
    MockLogger mock;
    Service service(mock);
    
    EXPECT_CALL(mock, log("Service working..."));
    service.doWork();
}
```

## 六、性能优化技巧

1. **无锁单例**（适用于C++11及以上）
```cpp
class LockFreeSingleton {
private:
    static std::atomic<LockFreeSingleton*> instance;
    static LockFreeSingleton* getInstance() {
        LockFreeSingleton* tmp = instance.load(std::memory_order_acquire);
        if (tmp == nullptr) {
            static LockFreeSingleton local;
            tmp = &local;
            instance.store(tmp, std::memory_order_release);
        }
        return tmp;
    }
};
```

2. **内存屏障优化**
```cpp
class MemoryBarrierSingleton {
private:
    static MemoryBarrierSingleton* getInstance() {
        static MemoryBarrierSingleton* instance = nullptr;
        MemoryBarrierSingleton* tmp = instance;
        std::atomic_thread_fence(std::memory_order_acquire);
        if (tmp == nullptr) {
            std::lock_guard<std::mutex> lock(mutex);
            tmp = instance;
            if (tmp == nullptr) {
                tmp = new MemoryBarrierSingleton();
                std::atomic_thread_fence(std::memory_order_release);
                instance = tmp;
            }
        }
        return tmp;
    }
};
```

## 七、常见问题解答

**Q1：单例模式是否违反单一职责原则？**

A：单例模式确实承担了"管理自身实例"和"业务功能"两个职责。为了保持设计整洁，建议：
1. 将实例管理逻辑与业务逻辑分离
2. 使用模板方法封装单例创建逻辑

**Q2：如何实现参数化单例初始化？**

A：可以通过初始化方法解决：
```cpp
class ParametricSingleton {
private:
    static ParametricSingleton& getInstance() {
        static ParametricSingleton instance;
        return instance;
    }
    
    ParametricSingleton() = default;

public:
    static void initialize(int param1, const std::string& param2) {
        auto& inst = getInstance();
        inst.init(param1, param2);
    }
    
    void init(int param1, const std::string& param2) {
        // 初始化逻辑
    }
};
```

**Q3：单例模式在DLL中的注意事项**

A：在Windows DLL中使用单例时要注意：
1. 每个DLL可能有自己的静态变量实例
2. 解决方案：
   - 使用显式导出函数获取单例
   - 将单例实例放在主可执行模块中

```cpp
// 在DLL头文件中
#ifdef SINGLETON_EXPORTS
#define SINGLETON_API __declspec(dllexport)
#else
#define SINGLETON_API __declspec(dllimport)
#endif

class SINGLETON_API CrossModuleSingleton {
public:
    static CrossModuleSingleton& getInstance();
};
```

## 八、现代C++改进方案

### 1. 使用std::shared_ptr管理单例

```cpp
class SharedSingleton {
private:
    static std::shared_ptr<SharedSingleton> instance;
    static std::mutex mutex;
    
    SharedSingleton() = default;

public:
    static std::shared_ptr<SharedSingleton> getInstance() {
        std::lock_guard<std::mutex> lock(mutex);
        if (!instance) {
            instance = std::shared_ptr<SharedSingleton>(new SharedSingleton());
        }
        return instance;
    }
    
    ~SharedSingleton() {
        // 清理资源
    }
};
```

### 2. 使用模板实现通用单例

```cpp
template<typename T>
class Singleton {
protected:
    Singleton() = default;
    ~Singleton() = default;

public:
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;
    
    static T& getInstance() {
        static T instance;
        return instance;
    }
};

// 使用示例
class MyManager : public Singleton<MyManager> {
    friend class Singleton<MyManager>;
    
private:
    MyManager() = default;
    
public:
    void manage() {
        // 业务逻辑
    }
};
```