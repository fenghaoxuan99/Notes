# 快速排序 (Quick Sort)

## 1. 基本思想

快速排序是一种分治算法，由Tony Hoare在1959年提出。它的基本思想是：
- 从数组中选择一个"基准"元素（pivot）
- 将数组分为两部分：小于基准的元素和大于基准的元素
- 对这两部分递归地应用相同的过程

快速排序的关键在于分区（partition）过程，它决定了算法的效率。

## 2. 代码实现

```cpp
#include <iostream>
#include <vector>
#include <algorithm> // for std::swap

// 分区函数
template <typename T>
int partition(std::vector<T>& arr, int low, int high) {
    T pivot = arr[high]; // 选择最后一个元素作为基准
    int i = low - 1;     // i是小于基准的元素的边界
    
    for (int j = low; j < high; ++j) {
        if (arr[j] < pivot) {
            ++i;
            std::swap(arr[i], arr[j]);
        }
    }
    std::swap(arr[i + 1], arr[high]);
    return i + 1; // 返回基准的最终位置
}

template <typename T>
int leftPartition(std::vector<T>& arr, int low, int high) {
    T pivot = arr[low];  // 选择第一个元素作为基准
    int i = low + 1;     // i从左向右扫描，指向第一个可能大于pivot的元素
    int j = high;        // j从右向左扫描，指向第一个可能小于pivot的元素

    while (true) {
        // 从左向右找第一个 >= pivot 的元素
        while (i <= j && arr[i] < pivot) i++;
        // 从右向左找第一个 <= pivot 的元素
        while (i <= j && arr[j] > pivot) j--;

        if (i >= j) break;  // 指针相遇，退出循环
        std::swap(arr[i], arr[j]);
        i++;
        j--;
    }

    // 将基准放到正确位置（j此时指向最后一个 <= pivot 的元素）
    std::swap(arr[low], arr[j]);
    return j;  // 返回基准的最终位置
}


// 快速排序主函数
template <typename T>
void quickSort(std::vector<T>& arr, int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high); // 分区索引
        
        // 递归排序分区
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}



// 包装函数，简化调用
template <typename T>
void quickSort(std::vector<T>& arr) {
    quickSort(arr, 0, arr.size() - 1);
}

int main() {
    std::vector<int> arr = {10, 7, 8, 9, 1, 5};
    
    std::cout << "Original array: ";
    for (int num : arr) {
        std::cout << num << " ";
    }
    std::cout << "\n";
    
    quickSort(arr);
    
    std::cout << "Sorted array: ";
    for (int num : arr) {
        std::cout << num << " ";
    }
    std::cout << "\n";
    
    return 0;
}
```

## 3. 时间复杂度分析

- **最好情况**：O(n log n) - 每次分区都能将数组均匀分成两部分
- **平均情况**：O(n log n)
- **最坏情况**：O(n²) - 当数组已经排序或所有元素相等时，每次分区只能减少一个元素

## 4. 稳定性说明

快速排序**不是稳定**的排序算法。在分区过程中，相等的元素可能会因为交换而改变相对顺序。

## 5. 动态示意图

以数组 [10, 7, 8, 9, 1, 5] 为例：

1. 初始数组: [10, 7, 8, 9, 1, 5]
2. 选择5作为基准(pivot)
3. 分区过程:
   - 比较10>5，不交换
   - 比较7>5，不交换
   - 比较8>5，不交换
   - 比较9>5，不交换
   - 比较1<5，交换1和10 → [1, 7, 8, 9, 10, 5]
   - 最后交换基准5和10 → [1, 5, 8, 9, 10, 7]
4. 现在5在正确位置，递归处理左子数组[1]和右子数组[8,9,10,7]
5. 右子数组选择7为基准:
   - 比较8>7，不交换
   - 比较9>7，不交换
   - 比较10>7，不交换
   - 交换基准7和8 → [7, 9, 10, 8]
6. 继续递归直到所有子数组有序

最终排序结果: [1, 5, 7, 8, 9, 10]

## 6. 典型应用场景

快速排序非常适合：
- 大规模数据排序
- 内存受限环境（原地排序）
- 对平均性能要求高的场景
- 不适合稳定性要求严格的场景

## 优化技巧

1. **三数取中法**：选择第一个、中间和最后一个元素的中值作为基准，避免最坏情况
2. **小数组切换**：对小规模子数组切换到插入排序（通常n < 10）
3. **尾递归优化**：减少递归调用栈深度
4. **三向切分**：处理大量重复元素的情况

## 测试代码示例

```cpp
#include <iostream>
#include <vector>
#include <random>
#include <chrono>
#include <algorithm>

// 优化的快速排序实现
template <typename T>
void optimizedQuickSort(std::vector<T>& arr, int low, int high) {
    // 小数组使用插入排序
    if (high - low < 10) {
        for (int i = low + 1; i <= high; ++i) {
            T key = arr[i];
            int j = i - 1;
            while (j >= low && arr[j] > key) {
                arr[j + 1] = arr[j];
                --j;
            }
            arr[j + 1] = key;
        }
        return;
    }
    
    // 三数取中选择基准
    int mid = low + (high - low) / 2;
    if (arr[mid] < arr[low]) std::swap(arr[low], arr[mid]);
    if (arr[high] < arr[low]) std::swap(arr[low], arr[high]);
    if (arr[mid] < arr[high]) std::swap(arr[mid], arr[high]);
    
    T pivot = arr[high];
    int i = low, j = high - 1;
    
    while (true) {
        while (arr[i] < pivot) ++i;
        while (j > low && arr[j] > pivot) --j;
        if (i >= j) break;
        std::swap(arr[i], arr[j]);
        ++i; --j;
    }
    
    std::swap(arr[i], arr[high]);
    
    // 尾递归优化
    if (i - low < high - i) {
        optimizedQuickSort(arr, low, i - 1);
        optimizedQuickSort(arr, i + 1, high);
    } else {
        optimizedQuickSort(arr, i + 1, high);
        optimizedQuickSort(arr, low, i - 1);
    }
}

template <typename T>
void optimizedQuickSort(std::vector<T>& arr) {
    optimizedQuickSort(arr, 0, arr.size() - 1);
}

int main() {
    // 生成随机数
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> dis(1, 10000);
    
    std::vector<int> arr(1000);
    for (auto& num : arr) {
        num = dis(gen);
    }
    
    // 测试标准快速排序
    auto arr1 = arr;
    auto start = std::chrono::high_resolution_clock::now();
    quickSort(arr1);
    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
    std::cout << "Standard QuickSort time: " << duration.count() << " microseconds\n";
    
    // 测试优化后的快速排序
    auto arr2 = arr;
    start = std::chrono::high_resolution_clock::now();
    optimizedQuickSort(arr2);
    end = std::chrono::high_resolution_clock::now();
    duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
    std::cout << "Optimized QuickSort time: " << duration.count() << " microseconds\n";
    
    // 验证排序正确性
    if (std::is_sorted(arr1.begin(), arr1.end()) && std::is_sorted(arr2.begin(), arr2.end())) {
        std::cout << "Both sorts are correct!\n";
    } else {
        std::cout << "Sorting error detected!\n";
    }
    
    return 0;
}
```

## 常见实现错误

1. **基准选择不当**：总是选择第一个或最后一个元素可能导致最坏情况
2. **递归终止条件错误**：忘记检查low < high导致无限递归
3. **分区逻辑错误**：边界条件处理不当，如j > low检查
4. **原地交换错误**：忘记在分区结束时将基准放到正确位置
5. **整数溢出**：在计算mid时使用(low+high)/2可能导致溢出，应使用low+(high-low)/2

## 与其他算法对比

| 特性        | 快速排序 | 归并排序 | 堆排序  |
|------------|---------|---------|--------|
| 时间复杂度(平均) | O(n log n) | O(n log n) | O(n log n) |
| 空间复杂度   | O(log n) 递归栈 | O(n) 辅助数组 | O(1) 原地 |
| 稳定性      | 不稳定    | 稳定     | 不稳定  |
| 最坏情况    | O(n²)    | O(n log n) | O(n log n) |
| 适用场景    | 通用排序  | 需要稳定性 | 内存受限 |

快速排序在大多数实际应用中是最快的通用排序算法，特别是当使用优化技巧后。然而，在最坏情况下性能会下降，因此在需要保证最坏情况性能时，堆排序或归并排序可能是更好的选择。


最左侧基准：
如果数组已经是升序排列，且每次选 arr[low] 作为基准 → 每次分区只能减少一个元素（类似冒泡排序），时间复杂度退化到 O(n²)。
最右侧基准：
如果数组已经是降序排列，且每次选 arr[high] 作为基准 → 同样会退化到 O(n²)。