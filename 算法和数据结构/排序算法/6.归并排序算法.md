### 归并排序（Merge Sort）

#### 1. 基本思想
归并排序采用**分治法**（Divide and Conquer）策略：
- **分**：将数组递归地分成两半，直到子数组长度为1（天然有序）。
- **治**：合并两个已排序的子数组，通过逐个比较元素，按顺序放入新数组。
- **核心操作**是合并（Merge），需要额外空间存储临时数组。

---

#### 2. 代码实现（递归 + 迭代）
```cpp
#include <vector>
#include <iostream>
using namespace std;

// 合并两个有序子数组
void merge(vector<int>& arr, int left, int mid, int right) {
    vector<int> temp(right - left + 1);
    int i = left, j = mid + 1, k = 0;

    while (i <= mid && j <= right) {
        if (arr[i] <= arr[j]) temp[k++] = arr[i++]; // 稳定性关键：<= 保持相等元素的顺序
        else temp[k++] = arr[j++];
    }
    while (i <= mid) temp[k++] = arr[i++];
    while (j <= right) temp[k++] = arr[j++];

    for (int p = 0; p < k; ++p) {
        arr[left + p] = temp[p];
    }
}

// 递归实现
void mergeSortRecursive(vector<int>& arr, int left, int right) {
    if (left >= right) return;
    int mid = left + (right - left) / 2; // 避免溢出
    mergeSortRecursive(arr, left, mid);
    mergeSortRecursive(arr, mid + 1, right);
    merge(arr, left, mid, right);
}

// 迭代实现（自底向上）
void mergeSortIterative(vector<int>& arr) {
    int n = arr.size();
    for (int size = 1; size < n; size *= 2) { // 子数组大小
        for (int left = 0; left < n - size; left += 2 * size) {
            int mid = left + size - 1;
            int right = min(left + 2 * size - 1, n - 1);
            merge(arr, left, mid, right);
        }
    }
}

// 测试代码
int main() {
    vector<int> arr = {12, 11, 13, 5, 6, 7};
    mergeSortRecursive(arr, 0, arr.size() - 1);
    // mergeSortIterative(arr);
    for (auto num : arr) cout << num << " "; // C++11: auto
    return 0;
}
```

---

#### 3. 时间复杂度分析
- **最好/最坏/平均**：均为 \(O(n \log n)\)。  
  - 分治层数为 \(\log n\)，每层合并操作耗时 \(O(n)\)。
- **空间复杂度**：\(O(n)\)（临时数组）。

---

#### 4. 稳定性说明
- **稳定**：合并时若遇到相等元素，优先取左子数组的元素，保持原始顺序。

---

#### 5. 动态示意图
以数组 `[38, 27, 43, 3, 9, 82, 10]` 为例：
1. **分阶段**：
   - 分割为 `[38, 27, 43, 3]` 和 `[9, 82, 10]`。
   - 继续分割直到每个子数组长度为1。
2. **合阶段**：
   - 合并 `[38]` 和 `[27]` 得到 `[27, 38]`。
   - 合并 `[43]` 和 `[3]` 得到 `[3, 43]`。
   - 合并 `[27, 38]` 和 `[3, 43]` 时，依次比较首元素，最终得到 `[3, 27, 38, 43]`。

---

#### 6. 典型应用场景
- **外部排序**：处理大规模数据时（如文件排序），归并排序适合分块加载到内存处理。
- **链表排序**：归并排序是链表排序的最佳选择（无需随机访问）。
- **稳定排序需求**：如按多关键字排序（先按年龄，再按姓名）。

---

### 对比与其他算法
| 特性         | 归并排序 | 快速排序 | 堆排序   |
|--------------|----------|----------|----------|
| 时间复杂度   | \(O(n \log n)\) | \(O(n \log n)\)（最坏 \(O(n^2)\)） | \(O(n \log n)\) |
| 空间复杂度   | \(O(n)\) | \(O(\log n)\)（递归栈） | \(O(1)\) |
| 稳定性       | 稳定     | 不稳定   | 不稳定   |
| 适用场景     | 大数据、外部排序 | 内存排序、通用 | 内存受限 |

---

### 常见实现错误
1. **边界处理**：`mid` 计算应使用 `left + (right - left) / 2` 避免溢出。
2. **临时数组索引**：合并时注意 `left` 的偏移量（`arr[left + p] = temp[p]`）。
3. **递归终止条件**：必须是 `left >= right` 而非 `==`，否则可能无限递归。

---

### 测试代码（计时示例，C++11）
```cpp
#include <chrono>
#include <random>
#include <algorithm>

void testMergeSort() {
    vector<int> arr(1000);
    random_device rd;
    mt19937 gen(rd());
    uniform_int_distribution<> dis(1, 10000);

    generate(arr.begin(), arr.end(), [&]() { return dis(gen); }); // C++11: lambda

    auto start = chrono::high_resolution_clock::now();
    mergeSortRecursive(arr, 0, arr.size() - 1);
    auto end = chrono::high_resolution_clock::now();

    auto duration = chrono::duration_cast<chrono::microseconds>(end - start);
    cout << "Time taken: " << duration.count() << " microseconds" << endl;
}
```