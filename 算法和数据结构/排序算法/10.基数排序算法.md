基数排序（Radix Sort）是一种非比较型的整数排序算法，它通过逐位（digit）或逐段（chunk）处理数据来实现排序。在网络库（如 muduo）的上下文中，基数排序可能用于高效处理网络数据包排序、定时器管理或其他需要稳定排序的场景。

### 基数排序核心思想
1. **按位分配**：从最低位（LSD）或最高位（MSD）开始，根据当前位的值将元素分配到不同的桶（Bucket）中。
2. **按序收集**：按桶的顺序（如 0→9）重新组合数据。
3. **重复处理**：对更高位重复上述过程，直到所有位处理完毕。

---

### 基数排序的典型实现（以 LSD 为例）
```cpp
void radixSort(std::vector<int>& arr) {
    if (arr.empty()) return;

    // 1. 找到最大值以确定位数
    int max_val = *std::max_element(arr.begin(), arr.end());
    int exp = 1; // 当前处理的位数（1, 10, 100...）

    // 2. 从低位到高位依次排序
    while (max_val / exp > 0) {
        countingSortByDigit(arr, exp);
        exp *= 10;
    }
}

void countingSortByDigit(std::vector<int>& arr, int exp) {
    std::vector<int> output(arr.size());
    std::vector<int> count(10, 0); // 0-9的计数器

    // 统计当前位的数字出现次数
    for (int num : arr) {
        int digit = (num / exp) % 10;
        count[digit]++;
    }

    // 计算累积分布（确定每个数字的最终位置）
    for (int i = 1; i < 10; i++) {
        count[i] += count[i - 1];
    }

    // 反向填充保证稳定性
    for (int i = arr.size() - 1; i >= 0; i--) {
        int digit = (arr[i] / exp) % 10;
        output[count[digit] - 1] = arr[i];
        count[digit]--;
    }

    arr = output;
}
```

---

### 在网络库（如 muduo）中的潜在应用
1. **定时器管理**  
   - 定时器通常需要按到期时间排序，时间戳是整数（如毫秒级），基数排序的 O(n) 时间复杂度比堆（O(n log n)）更高效。

2. **数据包重组**  
   - TCP 数据包可能乱序到达，若用序列号（32位整数）排序，基数排序可快速重组。

3. **连接管理**  
   - 对大量连接的 ID 或端口号排序时，基数排序比快速排序更稳定。

---

### 基数排序的优缺点
| **优点**                          | **缺点**                          |
|-----------------------------------|-----------------------------------|
| 时间复杂度 O(n)（k为最大位数）    | 仅适用于整数或可映射为整数的数据 |
| 稳定排序（保持相同键值的顺序）    | 需要额外 O(n) 空间                |
| 适合数据范围已知且分布均匀的场景  | 若位数 k 很大，实际效率可能下降   |

---