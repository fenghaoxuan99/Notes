# 插入排序详解

## 1. 基本思想

插入排序(Insertion Sort)是一种简单直观的排序算法，其基本思想是：**将数组分为已排序和未排序两部分，每次从未排序部分取出第一个元素，在已排序部分中找到合适的位置插入**。这个过程类似于我们整理扑克牌时的排序方式。

插入排序的特点是在处理几乎已经有序的数据时效率很高，可以达到接近线性的时间复杂度。

## 2. 代码实现

```cpp
#include <iostream>
#include <vector>

void insertionSort(std::vector<int>& arr) {
    int n = arr.size();
    for (int i = 1; i < n; ++i) { // 从第二个元素开始
        int key = arr[i]; // 当前要插入的元素
        int j = i - 1;    // 已排序部分的最后一个元素索引
        
        // 在已排序部分中从后向前扫描，寻找合适的插入位置
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j]; // 元素后移
            j--;
        }
        arr[j + 1] = key; // 插入到正确位置
    }
}

int main() {
    std::vector<int> arr = {12, 11, 13, 5, 6};
    
    std::cout << "排序前: ";
    for (int num : arr) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
    
    insertionSort(arr);
    
    std::cout << "排序后: ";
    for (int num : arr) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
    
    return 0;
}
```

## 3. 时间复杂度分析

- **最好情况**：O(n) - 当输入数组已经是有序的，每次只需要比较一次
- **最坏情况**：O(n²) - 当输入数组是逆序的，需要进行n(n-1)/2次比较和移动
- **平均情况**：O(n²) - 对于随机排列的数组

## 4. 稳定性说明

插入排序是**稳定**的排序算法。因为当遇到相等的元素时，插入排序会将新元素放在相等元素的后面，不会改变它们的相对顺序。

## 5. 动态示意图描述

以数组 [5, 2, 4, 6, 1, 3] 为例：

**初始状态**：[5] | [2,4,6,1,3] （竖线左边是已排序部分）

**第一轮**：
1. 取出2，与5比较 → 2 < 5 → 5后移 → [ ,5] | [4,6,1,3]
2. 插入2 → [2,5] | [4,6,1,3]

**第二轮**：
1. 取出4，与5比较 → 4 < 5 → 5后移 → [2, ,5] | [6,1,3]
2. 与2比较 → 4 > 2 → 停止
3. 插入4 → [2,4,5] | [6,1,3]

**第三轮**：
1. 取出6，与5比较 → 6 > 5 → 不移动
2. 直接插入 → [2,4,5,6] | [1,3]

**第四轮**：
1. 取出1，依次与6,5,4,2比较 → 全部后移 → [ ,2,4,5,6] | [3]
2. 插入1 → [1,2,4,5,6] | [3]

**第五轮**：
1. 取出3，与6,5,4比较 → 后移 → [1,2, ,4,5,6] | []
2. 与2比较 → 3 > 2 → 停止
3. 插入3 → [1,2,3,4,5,6]

## 6. 典型应用场景

插入排序特别适用于：
- 小规模数据的排序（n < 100）
- 几乎已经有序的数据（此时接近O(n)时间复杂度）
- 在线算法（数据逐步到达时实时排序）
- 作为更复杂算法（如快速排序、归并排序）的小规模数据排序优化

## 对比与注意事项

**内存占用**：插入排序是原地排序算法，只需要O(1)的额外空间（用于存储临时变量）。

**与冒泡排序、选择排序比较**：
- 插入排序在实际应用中通常比冒泡排序和选择排序更快
- 对于几乎有序的数据，插入排序效率最高
- 插入排序是稳定的，而选择排序不稳定

**常见实现错误**：
1. 外层循环起始索引错误（应该是1而不是0）
2. 内层循环的终止条件错误（应该是j >= 0）
3. 忘记保存当前元素的值（key = arr[i]）
4. 插入位置计算错误（应该是j+1而不是j）

**测试代码示例（C++11/17特性）**：

```cpp
#include <iostream>
#include <vector>
#include <random>
#include <chrono>
#include <algorithm>

void testInsertionSort() {
    // 使用C++11随机数生成器
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> dis(1, 10000);
    
    // 生成1000个随机数
    std::vector<int> arr(1000);
    auto generate = [&](){ return dis(gen); };
    std::generate(arr.begin(), arr.end(), generate);
    
    // 使用C++11计时器
    auto start = std::chrono::high_resolution_clock::now();
    
    insertionSort(arr);
    
    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
    
    // 检查是否已排序
    bool isSorted = std::is_sorted(arr.begin(), arr.end());
    
    std::cout << "排序" << (isSorted ? "成功" : "失败") 
              << "，耗时: " << duration.count() << " 毫秒" << std::endl;
}

int main() {
    testInsertionSort();
    return 0;
}
```