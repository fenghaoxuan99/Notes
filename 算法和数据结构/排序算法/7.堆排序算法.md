# 堆排序 (Heap Sort)

## 1. 基本思想

堆排序是一种基于二叉堆数据结构的比较排序算法。它利用了堆这种数据结构的特性：
- 堆是一个完全二叉树
- 每个节点的值都大于或等于（最大堆）或小于或等于（最小堆）其子节点的值

堆排序的基本思想是：
1. 将待排序序列构建成一个最大堆（升序排序时）
2. 此时堆顶元素（根节点）就是最大值
3. 将堆顶元素与末尾元素交换，此时末尾就是最大值
4. 然后将剩余n-1个元素重新构造成一个堆，这样会得到次大值
5. 反复执行上述步骤，直到堆的大小为1

## 2. 代码实现

```cpp
#include <iostream>
#include <vector>
#include <algorithm> // 用于std::swap

// 调整堆，使以root为根的子树成为最大堆
void heapify(std::vector<int>& arr, int n, int root) {
    int largest = root;    // 初始化largest为根节点
    int left  = 2 * root + 1;  // 左子节点
    int right = 2 * root + 2;  // 右子节点

    // 如果左子节点大于根节点
    if (left < n && arr[left] > arr[largest])
        largest = left;

    // 如果右子节点大于当前最大值
    if (right < n && arr[right] > arr[largest])
        largest = right;

    // 如果最大值不是根节点
    if (largest != root) {
        std::swap(arr[root], arr[largest]);
        // 递归调整受影响的子堆
        heapify(arr, n, largest);
    }
}

// 堆排序主函数
void heapSort(std::vector<int>& arr) {
    int n = arr.size();

    // 构建最大堆（从最后一个非叶子节点开始）
    for (int i = n / 2 - 1; i >= 0; i--)
        heapify(arr, n, i);

    // 一个个从堆顶取出元素
    for (int i = n - 1; i > 0; i--) {
        // 将当前最大值移到数组末尾
        std::swap(arr[0], arr[i]);
        // 调整剩余元素使其成为堆
        heapify(arr, i, 0);
    }
}

int main() {
    std::vector<int> arr = {12, 11, 13, 5, 6, 7};
    
    std::cout << "Original array: ";
    for (int num : arr) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    heapSort(arr);

    std::cout << "Sorted array: ";
    for (int num : arr) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

## 3. 时间复杂度分析

- **最好情况**：O(n log n) - 已经是一个堆的情况下
- **最坏情况**：O(n log n) - 无论输入数据如何，都需要构建堆和调整堆
- **平均情况**：O(n log n)

构建堆的时间复杂度是O(n)，而每次调整堆的时间复杂度是O(log n)，总共需要调整n-1次，所以总体时间复杂度为O(n log n)。

## 4. 稳定性说明

堆排序是**不稳定**的排序算法。因为在堆调整过程中，相等的元素可能会因为交换而改变相对顺序。

## 5. 动态示意图

以数组 [12, 11, 13, 5, 6, 7] 为例：

1. **构建最大堆**：
   - 从最后一个非叶子节点(索引1)开始调整：
     - 调整节点11(索引1): 11 < 6(左子)和7(右子)，不需要交换
     - 调整节点12(索引0): 12 < 13(右子)，交换12和13
   - 现在堆结构：[13, 11, 12, 5, 6, 7]

2. **排序过程**：
   - 交换堆顶13和末尾7，数组变为[7,11,12,5,6,13]
   - 调整前5个元素为堆：
     - 7 < 12(右子)，交换7和12
     - 7 < 6(左子)，不需要交换
     - 新堆：[12,11,7,5,6,13]
   - 交换堆顶12和末尾6，数组变为[6,11,7,5,12,13]
   - 调整前4个元素为堆：
     - 6 < 11(左子)，交换6和11
     - 6 < 7(右子)，交换6和7
     - 新堆：[11,7,6,5,12,13]
   - 重复上述过程直到堆大小为1

## 6. 典型应用场景

堆排序适用于：
- 需要O(n log n)时间复杂度且O(1)空间复杂度的场景
- 需要部分排序的情况（如找出前k个最大/最小元素）
- 嵌入式系统等内存受限环境（因为它是原地排序）

## 对比与其他算法

- **内存占用**：O(1)原地排序，优于归并排序(O(n))但不如快速排序(平均O(log n)递归栈)
- **适用数据**：适合大数据量，对数据初始顺序不敏感
- **缺点**：不稳定，缓存局部性较差（跳跃访问模式）

## 测试代码示例

```cpp
#include <iostream>
#include <vector>
#include <random>
#include <chrono>
#include <algorithm>

void testHeapSort(int size) {
    // 生成随机数
    std::vector<int> arr(size);
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> dis(1, 10000);
    
    for (auto& num : arr) {
        num = dis(gen);
    }
    
    // 计时
    auto start = std::chrono::high_resolution_clock::now();
    heapSort(arr);
    auto end = std::chrono::high_resolution_clock::now();
    
    // 验证排序
    bool sorted = std::is_sorted(arr.begin(), arr.end());
    
    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
    std::cout << "Size: " << size 
              << ", Time: " << duration.count() << " microseconds"
              << ", Sorted: " << (sorted ? "Yes" : "No") << std::endl;
}

int main() {
    // 测试不同大小的数组
    testHeapSort(1000);
    testHeapSort(10000);
    testHeapSort(100000);
    
    return 0;
}
```

## 常见实现错误

1. **堆调整的边界条件**：容易忘记检查左右子节点是否存在(left < n, right < n)
2. **构建堆的起始点**：应该从最后一个非叶子节点(n/2-1)开始，而不是从0开始
3. **堆大小处理**：在排序阶段，每次交换后堆的大小应该减1
4. **递归实现**：对于大数据量可能导致栈溢出，可以考虑迭代实现heapify
5. **索引计算**：容易混淆0-based和1-based索引计算（左子节点是2*i+1不是2*i）

## 迭代式heapify实现（避免递归栈溢出）

```cpp
void heapify(std::vector<int>& arr, int n, int root) {
    int current = root;
    while (true) {
        int largest = current;
        int left = 2 * current + 1;
        int right = 2 * current + 2;
        
        if (left < n && arr[left] > arr[largest])
            largest = left;
            
        if (right < n && arr[right] > arr[largest])
            largest = right;
            
        if (largest == current)
            break;
            
        std::swap(arr[current], arr[largest]);
        current = largest;
    }
}
```