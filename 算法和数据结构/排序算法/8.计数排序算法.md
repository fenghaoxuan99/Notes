计数排序（Counting Sort）是一种非比较型的整数排序算法，适用于数据范围不大且分布均匀的整数序列。它的核心思想是通过统计每个元素出现的次数，然后按顺序输出排序结果。

### **计数排序原理**
1. **统计频率**：遍历数组，统计每个元素出现的次数。
2. **计算前缀和**：将统计数组转换为前缀和形式，确定每个元素在排序后的位置。
3. **反向填充**：从原数组末尾开始，根据前缀和数组确定元素的位置，保证排序的稳定性。

---

### **计数排序代码实现（C++）**
```cpp
#include <vector>
#include <algorithm>

void countingSort(std::vector<int>& arr) {
    if (arr.empty()) return;

    // 1. 找到数组的最大值和最小值
    int max_val = *std::max_element(arr.begin(), arr.end());
    int min_val = *std::min_element(arr.begin(), arr.end());

    // 2. 计算数据范围，并初始化计数数组
    int range = max_val - min_val + 1;
    std::vector<int> count(range, 0);

    // 3. 统计每个元素出现的次数
    for (int num : arr) {
        count[num - min_val]++;
    }

    // 4. 计算前缀和（确定每个元素的最终位置）
    for (int i = 1; i < range; ++i) {
        count[i] += count[i - 1];
    }

    // 5. 反向填充排序后的数组（保证稳定性）
    std::vector<int> sorted(arr.size());
    for (int i = arr.size() - 1; i >= 0; --i) {
        int num = arr[i];
        int pos = count[num - min_val] - 1;
        sorted[pos] = num;
        count[num - min_val]--;
    }

    // 6. 将排序后的数组复制回原数组
    arr = sorted;
}
```

---

### **算法分析**
- **时间复杂度**：O(n + k)，其中 `n` 是数组长度，`k` 是数据范围（max - min + 1）。
- **空间复杂度**：O(n + k)，需要额外的计数数组和输出数组。
- **稳定性**：稳定（反向填充保证相同元素的相对顺序不变）。

---

### **适用场景**
- **适合**：数据范围较小（如年龄、分数等），且数据分布均匀的情况。
- **不适合**：数据范围过大（如 `INT_MAX` 到 `INT_MIN`），或包含浮点数的情况。

---

### **改进与优化**
1. **减少空间占用**：如果只需要排序，可以省略前缀和步骤，直接遍历计数数组输出。
2. **处理负数**：通过 `num - min_val` 映射到 `[0, range]` 范围，支持负数排序。
3. **并行优化**：大数据量时，可以分块统计计数，再合并结果。

---

### **与其他排序算法的对比**
- **vs 快速排序**：计数排序是线性时间排序，但仅适用于整数且范围较小的情况。
- **vs 桶排序**：计数排序是桶排序的特例（每个桶只放相同元素）。