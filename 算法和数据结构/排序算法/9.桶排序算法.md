# 桶排序 (Bucket Sort)

## 基本思想

桶排序是一种分布式排序算法，它将元素分散到多个"桶"中，然后对每个桶中的元素进行排序，最后按顺序合并所有桶中的元素。基本思想是：
1. 将待排序数组分到有限数量的桶中
2. 每个桶再分别排序（可以使用其他排序算法或递归地使用桶排序）
3. 最后将所有桶中的元素按顺序合并

桶排序假设输入数据均匀分布，这样每个桶中的元素数量大致相同，从而保证高效性。

## 代码实现

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

void bucketSort(vector<float>& arr) {
    if (arr.empty()) return;
    
    // 1. 创建n个空桶
    int n = arr.size();
    vector<vector<float>> buckets(n);
    
    // 2. 将数组元素放入不同的桶中
    float max_val = *max_element(arr.begin(), arr.end());
    float min_val = *min_element(arr.begin(), arr.end());
    float range = (max_val - min_val) / n;
    
    for (float num : arr) {
        int index = (num - min_val) / range;
        // 处理最大值的情况
        if (index == n) index = n - 1;
        buckets[index].push_back(num);
    }
    
    // 3. 对每个桶进行排序
    for (auto& bucket : buckets) {
        sort(bucket.begin(), bucket.end());
    }
    
    // 4. 合并所有桶中的元素
    int idx = 0;
    for (const auto& bucket : buckets) {
        for (float num : bucket) {
            arr[idx++] = num;
        }
    }
}

int main() {
    vector<float> arr = {0.897, 0.565, 0.656, 0.1234, 0.665, 0.3434};
    
    cout << "Original array: ";
    for (float num : arr) cout << num << " ";
    cout << endl;
    
    bucketSort(arr);
    
    cout << "Sorted array: ";
    for (float num : arr) cout << num << " ";
    cout << endl;
    
    return 0;
}
```

## 时间复杂度分析

- **最好情况**：O(n)，当输入数据均匀分布在各个桶中，且每个桶内元素数量很少时
- **平均情况**：O(n + k)，其中k是桶的数量
- **最坏情况**：O(n²)，当所有元素都分配到同一个桶中时

## 稳定性说明

桶排序是稳定的排序算法，因为在将元素分配到桶中时保持了它们的相对顺序，且在桶内排序时如果使用稳定的排序算法（如插入排序），整体排序就是稳定的。

## 动态示意图

1. 首先确定数组中的最大值和最小值，计算数据范围
2. 创建n个空桶（n为数组长度）
3. 遍历数组，将每个元素放入对应的桶中：
   - 计算元素应放入的桶索引：`(元素值 - 最小值) / (范围 / 桶数量)`
4. 对每个非空桶中的元素进行排序（通常使用插入排序）
5. 按顺序遍历所有桶，将桶中的元素合并回原数组

例如对[0.897, 0.565, 0.656, 0.1234, 0.665, 0.3434]排序：
- 创建6个桶
- 0.1234放入桶0
- 0.3434放入桶1
- 0.565放入桶2
- 0.656和0.665放入桶3
- 0.897放入桶5
- 对每个桶排序后合并

## 典型应用场景

1. 输入数据均匀分布在某个范围内
2. 浮点数排序
3. 外部排序（当数据量太大无法全部加载到内存时）
4. 作为基数排序的子程序

## 对比其他算法

- **内存占用**：需要额外O(n+k)的空间存储桶
- **适用数据特征**：最适合均匀分布的数据，对于分布不均匀的数据效率会下降

## 测试代码示例

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <random>
#include <chrono>

using namespace std;
using namespace std::chrono;

void bucketSort(vector<float>& arr) {
    if (arr.empty()) return;
    
    int n = arr.size();
    vector<vector<float>> buckets(n);
    
    float max_val = *max_element(arr.begin(), arr.end());
    float min_val = *min_element(arr.begin(), arr.end());
    float range = (max_val - min_val) / n;
    
    for (float num : arr) {
        int index = (num - min_val) / range;
        if (index == n) index = n - 1;
        buckets[index].push_back(num);
    }
    
    for (auto& bucket : buckets) {
        sort(bucket.begin(), bucket.end());
    }
    
    int idx = 0;
    for (const auto& bucket : buckets) {
        for (float num : bucket) {
            arr[idx++] = num;
        }
    }
}

int main() {
    // 生成1000个随机浮点数
    random_device rd;
    mt19937 gen(rd());
    uniform_real_distribution<> dis(0.0, 1.0);
    
    vector<float> arr(1000);
    generate(arr.begin(), arr.end(), [&](){ return dis(gen); });
    
    // 计时排序
    auto start = high_resolution_clock::now();
    bucketSort(arr);
    auto stop = high_resolution_clock::now();
    
    auto duration = duration_cast<microseconds>(stop - start);
    cout << "Time taken by bucket sort: " << duration.count() << " microseconds" << endl;
    
    // 验证排序结果
    if (is_sorted(arr.begin(), arr.end())) {
        cout << "Array is correctly sorted" << endl;
    } else {
        cout << "Array is not sorted correctly" << endl;
    }
    
    return 0;
}
```

## C++11/17特性说明

1. `auto`：用于自动类型推导，如`for (auto& bucket : buckets)`
2. Lambda表达式：`generate(arr.begin(), arr.end(), [&](){ return dis(gen); })`
3. 范围for循环：`for (float num : arr)`
4. 高精度计时器：`high_resolution_clock`

## 常见实现错误

1. 未处理空输入数组的情况
2. 桶索引计算错误，特别是最大值的情况
3. 没有正确计算数据范围和桶大小
4. 使用不稳定的排序算法对桶内元素排序，导致整体排序不稳定
5. 桶数量选择不当（通常应与输入数组大小相同）