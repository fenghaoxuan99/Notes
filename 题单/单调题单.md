# 一、单调栈
## §1.1 基础
原理讲解：单调栈【基础算法精讲 26】

模板：

def nearestGreater(nums: List[int]) -> Tuple[List[int], List[int]]:
    n = len(nums)
    # left[i] 是 nums[i] 左侧最近的严格大于 nums[i] 的数的下标，若不存在则为 -1
    left = [-1] * n
    st = []
    for i, x in enumerate(nums):
        while st and nums[st[-1]] <= x:  # 如果求严格小于，改成 >=
            st.pop()
        if st:
            left[i] = st[-1]
        st.append(i)

    # right[i] 是 nums[i] 右侧最近的严格大于 nums[i] 的数的下标，若不存在则为 n
    right = [n] * n
    st = []
    for i in range(n - 1, -1, -1):
        x = nums[i]
        while st and nums[st[-1]] <= x:
            st.pop()
        if st:
            right[i] = st[-1]
        st.append(i)

    return left, right

- [ ] 739. 每日温度
- [ ] 1475. 商品折扣后的最终价格 非暴力做法
- [ ] 496. 下一个更大元素 I
- [ ] 503. 下一个更大元素 II
- [ ] 901. 股票价格跨度 1709
- [ ] 853. 车队

## §1.2 进阶（选做）
- [ ] 1019. 链表中的下一个更大节点 1571
- [ ] 768. 最多能完成排序的块 II 1788
- [ ] 654. 最大二叉树 做到 O(n)
- [ ] 456. 132 模式 约 2000
- [ ] 3113. 边界元素是最大值的子数组数目 2046
- [ ] 2866. 美丽塔 II 2072
- [ ] 1944. 队列中可以看到的人数 2105
- [ ] 2454. 下一个更大元素 IV 2175
- [ ] 1130. 叶值的最小代价生成树 O(n) 做法
- [ ] 2289. 使数组按非递减顺序排列 2482
- [ ] 1776. 车队 II 2531
- [ ] 2736. 最大和查询 2533
- [ ] 3420. 统计 K 次操作以内得到非递减子数组的数目 2855 树形结构

### 思维扩展
- [ ] 962. 最大宽度坡 1608
- [ ] 3542. 将所有元素变为 0 的最少操作次数 1890
- [ ] 1124. 表现良好的最长时间段 1908

# 二、矩形
- [ ] 84. 柱状图中最大的矩形
- [ ] 1793. 好子数组的最大分数 1946
- [ ] 85. 最大矩形
- [ ] 221. 最大正方形
- [ ] 42. 接雨水 做法不止一种
- [ ] 1504. 统计全 1 子矩形
- [ ] 1277. 统计全为 1 的正方形子矩阵

# 三、贡献法
- [ ] 907. 子数组的最小值之和 1976
- [ ] 2104. 子数组范围和（最大值-最小值） O(n) 做法难度大约 2000
- [ ] 1856. 子数组最小乘积的最大值 2051
- [ ] 2818. 操作使得分最大 2397
- [ ] 2281. 巫师的总力量和（最小值×和） 2621
- [ ] 3430. 最多 K 个元素的子数组的最值之和 2645

### 思维扩展
- [ ] 2334. 元素值大于变化阈值的子数组 2381
- [ ] 2962. 统计最大元素出现至少 K 次的子数组·我的题解 中的思考题（解答见评论）

# 四、最小字典序
- [ ] 402. 移掉 K 位数字 约 1800
- [ ] 1673. 找出最具竞争力的子序列 1802
- [ ] 316. 去除重复字母 2185
- [ ] 316 扩展：重复个数不超过 limit
- [ ] 1081. 不同字符的最小子序列 同 316 题
- [ ] 321. 拼接最大数
- [ ] 2030. 含特定字母的最小子序列 2562
