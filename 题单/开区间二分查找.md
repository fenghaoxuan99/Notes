
## 核心思想

这种写法使用了一个**开区间** `[left, right)` 的思想，其中：
- `left` 是**不满足条件**的边界
- `right` 是**满足条件**的边界

## 具体分析

### 1. 初始化
```cpp
int left = matrix[0][0] - 1;    // 肯定不满足条件的值
int right = matrix[n - 1][n - 1]; // 肯定满足条件的值
```

### 2. 循环条件
```cpp
while (left + 1 < right)
```
当 `left` 和 `right` 相邻时停止，此时 `right` 就是我们要的答案。

### 3. 更新逻辑
```cpp
(check(mid) ? right : left) = mid;
```
- 如果 `mid` 满足条件 → `right = mid`（收紧右边界）
- 如果 `mid` 不满足条件 → `left = mid`（收紧左边界）

## 举个简单例子

假设我们要找数组 `[1,2,3,4,5]` 中第一个 >= 3 的数：

```
初始: left = 0, right = 5
满足条件：数字 >= 3
不满足条件：数字 < 3

第1轮: mid = 2, check(2) = false → left = 2
       [0,1,2] [3,4,5]
       
第2轮: mid = 3, check(3) = true → right = 3
       [0,1,2] [3] [4,5]
       
第3轮: mid = 2, 但 left+1 = 3 = right，结束
       
返回 right = 3
```

## 为什么这样做更好？

1. **逻辑清晰**：始终维护着"left不满足，right满足"的不变式
2. **避免边界错误**：不用纠结 `mid±1` 的问题
3. **统一模板**：适用于各种二分查找变体

## 关键点总结

- `left` 初始化为**肯定不满足**条件的值
- `right` 初始化为**肯定满足**条件的值  
- 循环结束时，`right` 就是第一个满足条件的值
- 每次都用 `mid` 来"收紧"区间，保持开区间的性质

这种写法虽然看起来陌生，但逻辑更清晰，不容易出错！