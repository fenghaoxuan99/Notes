# C++ Socket网络编程数据传输函数完全指南
## 1. 概述
Socket网络编程是C++网络应用开发的基础，数据传输函数的选择和使用直接影响程序的性能和可靠性。本指南将全面介绍三组核心数据传输函数，包括详细的使用方法、最佳实践和实际应用示例。

## 2. 面向连接的TCP传输函数：send()/recv()

### 2.1 核心特性

- **协议支持**：专门为TCP等面向连接的协议设计
- **流式传输**：数据作为字节流传输，不保留消息边界
- **高级控制**：支持多种标志位控制传输行为

### 2.2 函数原型详解

```cpp
ssize_t send(int sockfd, const void *buf, size_t len, int flags);
ssize_t recv(int sockfd, void *buf, size_t len, int flags);
```

参数说明：
- `sockfd`: 已连接的套接字描述符
- `buf`: 数据缓冲区指针
- `len`: 缓冲区长度
- `flags`: 控制标志位(可组合使用)

### 2.3 标志位详解

| 标志位 | 值 | 说明 | 适用场景 |
|--------|----|------|----------|
| MSG_OOB | 0x1 | 发送/接收带外数据 | 紧急消息传输 |
| MSG_DONTROUTE | 0x4 | 绕过路由表 | 本地网络测试 |
| MSG_DONTWAIT | 0x40 | 非阻塞操作 | 异步IO |
| MSG_NOSIGNAL | 0x4000 | 禁止SIGPIPE信号 | 避免进程终止 |
| MSG_WAITALL | 0x100 | 等待完整数据 | 需要完整数据包 |

### 2.4 完整示例：TCP Echo服务器

```cpp
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>
#include <cstring>
#include <iostream>

const int PORT = 8080;
const int BUFFER_SIZE = 1024;

int main() {
    // 创建TCP套接字
    int server_fd = socket(AF_INET, SOCK_STREAM, 0);
    
    // 设置SO_REUSEADDR选项
    int opt = 1;
    setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
    
    // 绑定地址
    struct sockaddr_in address;
    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_port = htons(PORT);
    bind(server_fd, (struct sockaddr*)&address, sizeof(address));
    
    // 监听
    listen(server_fd, 5);
    std::cout << "Server listening on port " << PORT << std::endl;
    
    // 接受连接
    int client_sock = accept(server_fd, nullptr, nullptr);
    
    // 通信循环
    char buffer[BUFFER_SIZE];
    while (true) {
        // 接收数据(使用MSG_WAITALL确保接收完整数据)
        ssize_t bytes_received = recv(client_sock, buffer, BUFFER_SIZE, MSG_WAITALL);
        if (bytes_received <= 0) break;
        
        // 处理数据(这里简单回显)
        ssize_t bytes_sent = send(client_sock, buffer, bytes_received, MSG_NOSIGNAL);
        if (bytes_sent < 0) {
            perror("send failed");
            break;
        }
    }
    
    close(client_sock);
    close(server_fd);
    return 0;
}
```

### 2.5 关键注意事项

1. **部分发送/接收处理**：
   ```cpp
   // 可靠send实现
   ssize_t reliable_send(int sockfd, const void *buf, size_t len) {
       size_t total_sent = 0;
       while (total_sent < len) {
           ssize_t sent = send(sockfd, (char*)buf + total_sent, len - total_sent, MSG_NOSIGNAL);
           if (sent <= 0) return sent;
           total_sent += sent;
       }
       return total_sent;
   }
   ```

2. **TCP粘包处理**：
   - 固定长度协议
   - 分隔符协议
   - 长度前缀协议(推荐)

3. **错误处理**：
   - ECONNRESET: 连接被对端重置
   - EAGAIN/EWOULDBLOCK: 非阻塞模式下的暂时不可用
   - EPIPE: 对端已关闭连接(可通过MSG_NOSIGNAL避免)

## 3. 无连接的UDP传输函数：sendto()/recvfrom()

### 3.1 核心特性

- **协议支持**：专为UDP等无连接协议设计
- **数据报特性**：保留消息边界，一次发送对应一次接收
- **地址灵活性**：每次通信可指定不同目标地址

### 3.2 函数原型详解

```cpp
ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,
               const struct sockaddr *dest_addr, socklen_t addrlen);
ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,
                 struct sockaddr *src_addr, socklen_t *addrlen);
```

### 3.3 完整示例：UDP时间服务器

```cpp
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <ctime>
#include <iostream>

const int PORT = 9090;
const int BUFFER_SIZE = 1024;

int main() {
    // 创建UDP套接字
    int sockfd = socket(AF_INET, SOCK_DGRAM, 0);
    
    // 绑定地址
    struct sockaddr_in server_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(PORT);
    bind(sockfd, (struct sockaddr*)&server_addr, sizeof(server_addr));
    
    std::cout << "UDP Time Server running on port " << PORT << std::endl;
    
    // 通信循环
    char buffer[BUFFER_SIZE];
    struct sockaddr_in client_addr;
    socklen_t addr_len = sizeof(client_addr);
    
    while (true) {
        // 接收请求
        ssize_t bytes_received = recvfrom(sockfd, buffer, BUFFER_SIZE, 0,
                                         (struct sockaddr*)&client_addr, &addr_len);
        
        if (bytes_received > 0) {
            // 获取当前时间
            time_t now = time(nullptr);
            std::string time_str = ctime(&now);
            
            // 发送时间给客户端
            sendto(sockfd, time_str.c_str(), time_str.length(), 0,
                  (struct sockaddr*)&client_addr, addr_len);
        }
    }
    
    close(sockfd);
    return 0;
}
```

### 3.4 高级应用：UDP可靠性实现

```cpp
// 可靠UDP发送函数(带超时和重试)
ssize_t reliable_udp_send(int sockfd, const void *buf, size_t len, 
                         const struct sockaddr *dest_addr, socklen_t addrlen,
                         int max_retries = 3, int timeout_sec = 2) {
    int retries = 0;
    while (retries < max_retries) {
        // 设置发送超时
        struct timeval tv;
        tv.tv_sec = timeout_sec;
        tv.tv_usec = 0;
        setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv));
        
        ssize_t sent = sendto(sockfd, buf, len, 0, dest_addr, addrlen);
        if (sent == len) return sent;
        
        retries++;
        std::cerr << "Send failed, retry " << retries << "/" << max_retries << std::endl;
    }
    return -1;
}
```

### 3.5 关键注意事项

1. **MTU限制**：单个UDP数据报不应超过路径MTU(通常1472字节)
2. **无序到达**：应用层需处理数据包乱序问题
3. **广播/组播**：
   ```cpp
   // 启用广播
   int broadcast = 1;
   setsockopt(sockfd, SOL_SOCKET, SO_BROADCAST, &broadcast, sizeof(broadcast));
   
   // 设置组播TTL
   unsigned char ttl = 1; // 本地网络
   setsockopt(sockfd, IPPROTO_IP, IP_MULTICAST_TTL, &ttl, sizeof(ttl));
   ```

## 4. 通用文件IO函数：write()/read()

### 4.1 核心特性

- **通用性**：适用于文件、管道、套接字等多种描述符
- **简单性**：无复杂标志位，基本IO操作
- **阻塞行为**：默认阻塞，可通过fcntl设为非阻塞

### 4.2 函数原型

```cpp
ssize_t write(int fd, const void *buf, size_t count);
ssize_t read(int fd, void *buf, size_t count);
```

### 4.3 示例：简单的TCP代理

```cpp
void forward_data(int src_fd, int dst_fd) {
    char buffer[4096];
    ssize_t bytes_read;
    
    while ((bytes_read = read(src_fd, buffer, sizeof(buffer))) > 0) {
        ssize_t bytes_written = write(dst_fd, buffer, bytes_read);
        if (bytes_written < 0) {
            perror("write failed");
            break;
        }
    }
    
    if (bytes_read < 0) {
        perror("read failed");
    }
}
```

### 4.4 关键注意事项

1. **非阻塞IO处理**：
   ```cpp
   // 设置非阻塞模式
   int flags = fcntl(fd, F_GETFL, 0);
   fcntl(fd, F_SETFL, flags | O_NONBLOCK);
   
   // 非阻塞读取处理
   ssize_t nb_read(int fd, void *buf, size_t count) {
       ssize_t bytes = read(fd, buf, count);
       if (bytes < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {
           return 0; // 没有数据可用
       }
       return bytes;
   }
   ```

2. **性能考虑**：对于大块数据传输，write()/read()可能比send()/recv()有轻微性能优势

## 5. 高级应用场景

### 5.1 带超时的接收实现

```cpp
ssize_t recv_with_timeout(int sockfd, void *buf, size_t len, int timeout_sec) {
    fd_set read_fds;
    FD_ZERO(&read_fds);
    FD_SET(sockfd, &read_fds);
    
    struct timeval tv;
    tv.tv_sec = timeout_sec;
    tv.tv_usec = 0;
    
    int ready = select(sockfd + 1, &read_fds, nullptr, nullptr, &tv);
    if (ready == 0) return -2; // 超时
    if (ready == -1) return -1; // 错误
    
    return recv(sockfd, buf, len, 0);
}
```

### 5.2 零拷贝发送文件

```cpp
#include <sys/sendfile.h>

void send_file(int sockfd, int filefd, off_t file_size) {
    off_t offset = 0;
    while (offset < file_size) {
        ssize_t sent = sendfile(sockfd, filefd, &offset, file_size - offset);
        if (sent <= 0) {
            perror("sendfile failed");
            break;
        }
        offset += sent;
    }
}
```

### 5.3 多播通信示例

```cpp
// 加入多播组
struct ip_mreq mreq;
mreq.imr_multiaddr.s_addr = inet_addr("239.255.255.250");
mreq.imr_interface.s_addr = htonl(INADDR_ANY);
setsockopt(sockfd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &mreq, sizeof(mreq));

// 设置多播TTL
unsigned char ttl = 32; // 可跨路由器
setsockopt(sockfd, IPPROTO_IP, IP_MULTICAST_TTL, &ttl, sizeof(ttl));

// 发送多播数据
struct sockaddr_in multicast_addr = {0};
multicast_addr.sin_family = AF_INET;
multicast_addr.sin_addr.s_addr = inet_addr("239.255.255.250");
multicast_addr.sin_port = htons(1900);

sendto(sockfd, "Multicast Message", 17, 0, 
      (struct sockaddr*)&multicast_addr, sizeof(multicast_addr));
```

## 6. 性能优化技巧

1. **缓冲区大小调整**：
   ```cpp
   // 设置接收缓冲区大小(256KB)
   int recv_buf_size = 256 * 1024;
   setsockopt(sockfd, SOL_SOCKET, SO_RCVBUF, &recv_buf_size, sizeof(recv_buf_size));
   ```

2. **Nagle算法控制**：
   ```cpp
   // 禁用Nagle算法(低延迟应用)
   int flag = 1;
   setsockopt(sockfd, IPPROTO_TCP, TCP_NODELAY, &flag, sizeof(flag));
   ```

3. **批量发送优化**：
   ```cpp
   // 使用writev进行向量IO
   struct iovec iov[2];
   iov[0].iov_base = header;
   iov[0].iov_len = header_len;
   iov[1].iov_base = body;
   iov[1].iov_len = body_len;
   
   writev(sockfd, iov, 2);
   ```

## 7. 跨平台注意事项

1. **Windows差异**：
   - 使用`WSASend()`/`WSARecv()`代替send()/recv()获得更好性能
   - 错误码不同(如WSAEWOULDBLOCK代替EAGAIN)

2. **BSD衍生系统**：
   - 支持MSG_NOSIGNAL标志
   - 提供sendmsg()/recvmsg()等高级接口

3. **Linux特有优化**：
   - 支持splice()和tee()实现零拷贝
   - 提供TCP_CORK选项控制报文合并

## 8. 总结对比表

| 特性 | send()/recv() | sendto()/recvfrom() | write()/read() |
|------|--------------|---------------------|---------------|
| 协议支持 | TCP/SCTP | UDP/RAW | 通用 |
| 连接需求 | 需连接 | 无连接 | 视描述符 |
| 地址处理 | 连接时指定 | 每次指定 | 不适用 |
| 标志位 | 丰富 | 丰富 | 无 |
| 消息边界 | 不保留 | 保留 | 视协议 |
| 性能 | 高 | 高 | 极高 |
| 复杂度 | 中 | 中 | 低 |
| 推荐场景 | TCP应用 | UDP应用 | 简单IO/文件传输 |